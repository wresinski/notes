#+STARTUP: indent

* BFS
** 用队列进行广度优先搜索时要及时标记，别等拿出来时再标记，不然会产生多次重复
*** 例题[[https://leetcode-cn.com/problems/number-of-islands/][200. 岛屿数量]]
#+BEGIN_SRC cpp
  void bfs(vector<vector<char>> &grid, int i, int j) {
      int sizeX = grid.size();
      int sizeY = grid[0].size();
      queue<pair<int, int>> q;
      q.push(make_pair(i, j));
      while (!q.empty()) {
          i = q.front().first;
          j = q.front().second;
          q.pop();
          // grid[i][j] = '0'; //不应该写在这里，不然会产生多次重复
          if (i > 0 && grid[i - 1][j] == '1') {
              grid[i - 1][j] = '0';
              q.push(make_pair(i - 1, j));
          }
          if (j > 0 && grid[i][j - 1] == '1') {
              grid[i][j - 1] = '0';
              q.push(make_pair(i, j - 1));
          }
          if (i < sizeX - 1 && grid[i + 1][j] == '1') {
              grid[i + 1][j] = '0';
              q.push(make_pair(i + 1, j));
          }
          if (j < sizeY - 1 && grid[i][j + 1] == '1') {
              grid[i][j + 1] = '0';
              q.push(make_pair(i, j + 1));
          }
      }
  }
#+END_SRC
* DFS
** 可以用一个栈来实现深度优先搜索，也可用递归
*** 例题[[https://leetcode.cn/problems/course-schedule/][207. 课程表]]
**** 代码1（深度优先搜索）
#+BEGIN_SRC cpp
  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
      vector<vector<int>> map(numCourses);
      vector<int> sign(numCourses, 0);

      for (int i=0; i<prerequisites.size(); ++i) {
          map[prerequisites[i][0]].push_back(prerequisites[i][1]);
      }

      for (int k=0; k<numCourses; ++k) {
          if (sign[k]==2) continue;
          stack<int> dfs;
          dfs.push(k);
          while (!dfs.empty()) {
              int i = dfs.top();
              if (sign[i]==0) {
                  sign[i] = 1;
                  for (int j=0; j<map[i].size(); ++j) {
                      if (sign[map[i][j]]==0) {
                          dfs.push(map[i][j]);
                      }
                      else if (sign[map[i][j]]==1) {
                          return false;
                      }
                  }
              }
              else {
                  sign[i] = 2;
                  dfs.pop();
              }
          }
      }
      return true;
  }
#+END_SRC
***** 通过深度优先搜索遍历有向图，借助一个数组来标记每个元素的状态；0表示未搜索，遍历到时可以开始搜索，1表示正在被搜索，遍历到时表示有环，2表示已经搜索结束加入已修课程，是可依赖的
***** 注意当使用栈进行深度搜索时，搜索到的元素不要马上弹出，要等到其子节点搜索结束时再弹出，并标记为2
**** 代码2（类广度优先搜索）
#+BEGIN_SRC cpp
  bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
      vector<vector<int>> map(numCourses);
      vector<int> sign(numCourses, 0);

      for (int i=0; i<prerequisites.size(); ++i) {
          map[prerequisites[i][0]].push_back(prerequisites[i][1]);
          sign[prerequisites[i][1]]++;
      }

      int count_zero = 0;
      while (1) {
          bool has_zero = false;
          for (int i=0; i<numCourses; ++i) {
              if (sign[i]==0) {
                  has_zero = true;
                  sign[i] = -1;
                  count_zero++;
                  for (int j=0; j<map[i].size(); ++j) {
                      --sign[map[i][j]];
                  }
              }
          }
          if (has_zero==false) break;
      }
      return count_zero==numCourses;
  }
#+END_SRC
***** 取出所有入度为0的元素，并删除它们的所有出边，再取出入度为0的元素，如此循环，直到没有入度为0的元素可取
***** 对于有向无环图，这样肯定可以取完所有元素；对于有环的有向图，环循环依赖，无法产生入度为0的元素
* 位运算
** 部分按位取反技巧：num^((long)(1<<i)-1)
*** 例题[[https://leetcode-cn.com/problems/number-complement/][476. 数字的补数]]
* 动态规划
** 最简单的动态规划问题
*** 例题[[https://leetcode-cn.com/problems/climbing-stairs/][70. 爬楼梯(不需要用数组，只需要记住前两个元素）]]
*** 例题[[https://leetcode-cn.com/problems/fibonacci-number/][509. 斐波那契数（同上）]]
*** 例题[[https://leetcode-cn.com/problems/counting-bits/][338. 比特位计数]] 
*** 例题[[https://leetcode-cn.com/problems/triangle/][120. 三角形最小路径和]]
*** 例题[[https://leetcode-cn.com/problems/palindrome-partitioning-ii/][132. 分割回文串 II]]
#+BEGIN_SRC  cpp
  int minCut(string s) {
      int n = s.size();
      vector<vector<int>> f(n, vector<int>(n, 1));
      for (int i=n-1; i>=0; --i) {
          for (int j=i+1; j<n; ++j) {
              f[i][j] = f[i+1][j-1]&&(s[i]==s[j]);
          }
      }

      vector<int> res(n, INT_MAX);
      for (int i=0; i<n; ++i) {
          if (f[0][i]) {
              res[i] = 0;
              continue;
          }
          int j = i-1;
          while (j>=0) {
              if (f[j+1][i]) {
                  res[i] = min(res[i], res[j]+1);
                  if (res[j]==0) break; // 后面不可能更小了，提前结束
              }
              j--;
          }
      }
      return res[n-1];
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/longest-increasing-subsequence/][300. 最长递增子序列]]
**** 定义f[i]为考虑前n个元素，第i个数字结尾的最长上升子序列的长度，注意nums[i]必须被选取；则状态转移方程为：f[i]=max(f[j])+1,(0<=j<i且nums[j]<nums[i])；最终res=max(f[i])；
**** 代码
#+BEGIN_SRC cpp
  int lengthOfLIS(vector<int>& nums) {
      int n = nums.size();
      vector<int> f(n, 1);
      int res = 1;
      for (int i=1; i<n; ++i) {
          for (int j=i-1; j>=0; --j) {
              if (nums[i]>nums[j]) {
                  f[i] = max(f[i], f[j]+1);
              }
          }
          res = max(res, f[i]); 
      }
      return res;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/word-break/][139. 单词拆分]]
**** 状态转移方程：dp[i]=dp[j]&&check(s[j..i-1])；其中，dp为记录前i个字符串能否被分割的bool数组，check为确定s是否在字典中；注意j可以为0，此时只需判断s是否在字典中
**** 代码
#+BEGIN_SRC cpp
  bool wordBreak(string s, vector<string>& wordDict) {
      int maxl = 0;
      unordered_set<string> set;
      for (auto iter = wordDict.begin(); iter!=wordDict.end(); ++iter) {
          set.insert(*iter);
          maxl = max(maxl,(int)(*iter).size());
      }
      int n = s.size();
      vector<int> b(n);
      for (int i=0; i<n; ++i) {
          for (int j=i; j>i-maxl&&j>=0; --j) {
              if ((j==0||b[j-1])&&set.count(s.substr(j,i-j+1))) { // 当j==0当s1为空串，只判断s2是否在set中
                  b[i] = 1;
                  break;
              }
          }
      }
      return b[n-1];
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/coin-change/][322. 零钱兑换]]
*** 例题[[https://leetcode-cn.com/problems/unique-binary-search-trees/][96. 不同的二叉搜索树]]
**** 代码1（动态规划）
#+BEGIN_SRC cpp
  int numTrees(int n) {
      vector<int> dp(n+1);
      dp[0] = 1;
      dp[1] = 1;
      for (int i=2; i<=n; ++i) {
          for (int j=0; j<i; ++j) {
              dp[i] += dp[j]*dp[i-j-1];
          }
      }
      return dp[n];
  }
#+END_SRC
***** 对于n个数，遍历每个数作为根节点，并利用动态规划递归构建左右子树
**** 代码2（卡塔兰数）
#+BEGIN_SRC cpp
  int numTrees(int n) {
      long long C = 1;
      for (int i = 0; i < n; ++i) {
          C = C * 2 * (2 * i + 1) / (i + 2);
      }
      return (int)C;
  }
#+END_SRC
** 二维动态规划
*** 例题[[https://leetcode-cn.com/problems/longest-palindromic-substring/][5. 最长回文子串]]
**** 代码1（普通动态规划，时间复杂度O(n^2)）
#+BEGIN_SRC cpp
  string longestPalindrome(string s) {
      int n = s.size();
      vector<vector<int>> map(n, vector<int>(n, 1));
      int res = 1;
      int x = 0, y = 0;
      for (int k=1; k<n; ++k) {
          for (int i=0,j=k; i<n&&j<n; ++i,++j) {
              map[i][j] = map[i+1][j-1]&&s[i]==s[j];
              if (map[i][j]&&j-i+1>res) {
                  res = j-i+1;
                  x = i;
                  y = j;
              }
          }
      }
      return s.substr(x, res);
  }
#+END_SRC
***** 状态转移方程：dp[i][j]=dp[i+1][j-1]&&s[i]==s[j]；其中初始条件为dp[i][i]=1，以及当s[i]==s[i+1]时，dp[i][i+1]=1
**** 代码2（中心扩展算法，时间复杂度O(n^2)）
#+BEGIN_SRC cpp
  string longestPalindrome(string s) {
      int n = s.size();
      int res = 1;
      int x = 0, y = 0;
      for (int k=0; k<n; ++k) {
          int i = k;
          int j = k;
          while (i>0&&j<n-1&&s[--i]==s[++j]) {
              if (res<j-i+1) {
                  res = j-i+1;
                  x = i;
                  y = j;
              }
          }
      }
      for (int k=0; k<n-1; ++k) {
          int i = k;
          int j = k+1;
          if (s[i]!=s[j]) continue;
          if (res<j-i+1) { // 这里的两位初值也要算入
              res = j-i+1;
              x = i;
              y = j;
          }
          while (i>0&&j<n-1&&s[--i]==s[++j]) {
              if (res<j-i+1) {
                  res = j-i+1;
                  x = i;
                  y = j;
              }
          }
      }
      return s.substr(x, res);
  }
#+END_SRC
***** 可以从几个初值条件，沿着dp[++i][--j]的方向去推所有的可能性，如果其中某个情况不是回文串，则该条链上之后的都不是
**** 代码3（Manacher算法，时间复杂度O(n)）
#+BEGIN_SRC cpp
  string longestPalindrome(string s) {
      string t = "#";
      for (char& c : s) {
          t += c;
          t += '#';
      }
      s = t+'#';

      int res = 1;
      int x = 0, y = 0;
      int center = -1, right = -1;
      vector<int> len(s.size());
      for (int i=0; i<s.size(); ++i) {
          if (i<=right) {
              int left = center*2-right;
              int len_min = min(len[left], right-i);
              len[i] = helper(s, i-len_min, i+len_min);
          }
          else {
              len[i] = helper(s, i, i);
          }

          if (i+len[i]>right) {
              right = i+len[i];
              center = i;
          }

          if (len[i]*2+1>res) {
              res = len[i]*2+1;
              x = i-len[i];
              y = i+len[i];
          }
      }

      string string_res;
      for (int i=x; i<=y; ++i) {
          if (s[i]!='#') {
              string_res += s[i];
          }
      }

      return string_res;
  }
  int helper(string& s, int i, int j) {
      int res = 1;
      while (i>0&&j<s.size()-1&&s[--i]==s[++j]) {
          if (res<j-i+1) {
              res = j-i+1;
          }
      }
      return (res-1)/2;
  }
#+END_SRC
***** 该算法通过待求起始位置对称点位的臂长来确定待求起始位置链上的起始条件，借此来减少链上的计算次数
*** 例题[[https://leetcode-cn.com/problems/regular-expression-matching/][10. 正则表达式匹配]]
**** 代码
#+BEGIN_SRC cpp
  bool isMatch(string s, string p) {
      int m = s.size();
      int n = p.size();

      auto match = [&](int i, int j) {
          if (i<0||j<0) return 0;
          if (p[j]=='.') {
              return 1;
          }
          else if (s[i]==p[j]) {
              return 1;
          }
          else return 0;
      };

      vector<vector<int>> dp(m+1, vector<int>(n+1));
      dp[0][0] = 1;
      for (int i=0; i<=m; ++i) {
          for (int j=1; j<=n; ++j) {
              if (p[j-1]=='*') {
                  if (match(i-1, j-2)) {
                      dp[i][j] = dp[i-1][j]||dp[i][j-2];
                  }
                  else {
                      dp[i][j] = dp[i][j-2];
                  }
              }
              else {
                  if (match(i-1, j-1)) {
                      dp[i][j] = dp[i-1][j-1];
                  }
              } 
          }
      }
      return dp[m][n];
  }
#+END_SRC
***** 令f[i][j]为s的前i个字符和p的前j个字符是否匹配
***** 当p[j-1]为字母或者" . "时，f[i][j]取决于p[j-1]能否和s[i-1]匹配以及f[i-1][j-1]是否匹配
***** 当p[j-1]为" * "时
****** 如果p[j-1]可以和s[i-1]匹配，则f[i][j]取决于f[i-1][j]或[f[i][j-2]
****** 如果p[j-1]不能和s[i-1]匹配，则f[i][j]取决于f[i][j-2]
***** 动态规划的初始边界条件为f[0][0]=true
*** 例题[[https://leetcode.cn/problems/maximal-square/][221. 最大正方形]]
#+BEGIN_SRC cpp
  int maximalSquare(vector<vector<char>>& matrix) {
      int x = matrix.size();
      int y = matrix[0].size();
      int res = 0;
      vector<vector<int>> dp(x, vector<int>(y));
      for (int i=0; i<x; ++i) {
          dp[i][0] = matrix[i][0]-'0';
          res = max(res, dp[i][0]);
      }
      for (int i=0; i<y; ++i) {
          dp[0][i] = matrix[0][i]-'0';
          res = max(res, dp[0][i]);
      }
      for (int i=1; i<x; ++i) {
          for (int j=1; j<y; ++j) {
              dp[i][j] = matrix[i][j]=='1'?min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]})+1:0;
              res = max(res, dp[i][j]);
          }
      }
      return res*res;
  }
#+END_SRC
**** 令dp[i][j]为以(i,j)为右下角的最大正方形的边长值，则状态转移方程为：dp[i][j]=min(dp[i-1][j],dp[i-1][j-],dp[i][j-1])+1
** 可空间优化的动态规划问题
*** 例题[[https://leetcode-cn.com/problems/minimum-path-sum/][64. 最小路径和]]
*** 例题[[https://leetcode-cn.com/problems/unique-paths/][62. 不同路径]]
*** 例题[[https://leetcode-cn.com/problems/unique-paths-ii/][63. 不同路径 II]]
#+BEGIN_SRC cpp
  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
      int m = obstacleGrid.size();
      int n = obstacleGrid[0].size();
      vector<int> path(n);
      path[0] = obstacleGrid[0][0]==0?1:0;
      for (int i=0; i<m; ++i) {
          for (int j=0; j<n; ++j) {
              if(i==0&&j==0) continue;
              int up = i>0?path[j]:0;
              int left = j>0?path[j-1]:0;
              path[j] = obstacleGrid[i][j]==0?up+left:0;
          }
      }
      return path[n-1];
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/longest-common-subsequence/][1143. 最长公共子序列]]
**** 状态转移方程：当text1[i]==text2[j]时，dp[i][j]=dp[i-1][j-1]+1；当text1[i]!=text2[j]，dp[i][j]=max(dp[i-1][j],dp[i][j-1])；二维数组dp[i][j]为text1前i和text2前j的最长公共子串长度 
**** 代码
#+BEGIN_SRC cpp
  int longestCommonSubsequence(string text1, string text2) {
      int m = text1.size();
      int n = text2.size();
      vector<int> dp(n+1); // 数组优化为一维
      int temp1;
      for (int i=1; i<=m; ++i) {
          temp1 = 0;
          for (int j=1; j<=n; ++j) {
              int temp2 = temp1;
              temp1 = text1[i-1]==text2[j-1]?(dp[j-1]+1):max(dp[j],temp1);
              dp[j-1] = temp2;
          }
          dp[n] = temp1;
      }
      return temp1;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/edit-distance/][72. 编辑距离]]
**** 状态转移方程：当word1[i]==word2[j]时，dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1])；当word1[i]!=word2[j]时，d[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1)；二维数组dp[i][j]为word1前i个字母变化为word2前j个字母的最小编辑次数
**** 原理：任何的编辑状态，本质最后一次编辑只有三种可能：增、删、改；我们假定最后一次编辑是在字串末尾，因为在中间的编辑相当于是在某个前缀串的末尾编辑，即之前已经考虑过了；因此d[i][j]只可能是由d[i][j-1]增加一次、d[i-1][j]删除一次、d[i-1][j-1]改变一次而来；注意当word1[i]==word2[j]时，d[i-1][j-1]变换完不需要再改变
**** 代码1(空间复杂度O(n^2)）
#+BEGIN_SRC cpp
  int minDistance(string word1, string word2) {
      int m = word1.size();
      int n = word2.size();
      vector<vector<int>> dp(m+1, vector<int>(n+1));
      for (int i=1; i<=m; ++i) dp[i][0] = i;
      for (int i=1; i<=n; ++i) dp[0][i] = i;
      for (int i=1; i<=m; ++i) {
          for (int j=1; j<=n; ++j) {
              dp[i][j] = min(dp[i-1][j], dp[i][j-1]);
              dp[i][j] = min(dp[i][j], word1[i-1]==word2[j-1]?(dp[i-1][j-1]-1):dp[i-1][j-1]);
              dp[i][j]++;
          }
      }
      return dp[m][n];
  }
#+END_SRC
**** 代码2(空间复杂度O(n)
#+BEGIN_SRC cpp
    int minDistance(string word1, string word2) {
	int m = word1.size();
	int n = word2.size();
	vector<int> dp(n+1);
	for (int i=1; i<=n; ++i) dp[i] = i;
	int temp1;
	for (int i=1; i<=m; ++i) {
	    temp1 = i;
	    for (int j=1; j<=n; ++j) {
		int temp2 = temp1;
		if (word1[i-1]==word2[j-1]) { // d[i-1][j]-1<=d[i][j]<=d[i-1][j]恒成立，则dp[i][j]=1+min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1]-1)＝dp[i-1][j-1]，dp[i][j-1]>=dp[i-1][j-1]-1，dp[i-1][j]>=dp[i-1][j-1]-1恒成立
		    temp1 = dp[j-1]-1;
		}
		else {
		    temp1 = min(dp[j], temp1);
		    temp1 = min(temp1, dp[j-1]);
		}
		temp1++;
		dp[j-1] = temp2;
	    }
	    dp[n] = temp1;
	}
	return dp[n];
    }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/maximum-product-subarray/][152. 乘积最大子数组]]
#+BEGIN_SRC cpp
  int maxProduct(vector<int>& nums) {
      int n = nums.size();
      int dpmax = nums[0], dpmin = nums[0];
      int res = nums[0];
      for (int i=1; i<n; ++i) {
          if (nums[i]>0) {
              dpmax = max(dpmax*nums[i], nums[i]);
              dpmin = min(dpmin*nums[i], nums[i]);
          }
          else {
              int temp = dpmax;
              dpmax = max(dpmin*nums[i], nums[i]);
              dpmin = min(temp*nums[i], nums[i]);
          }
          res = max(res, dpmax);
      }
      return res;
  }
#+END_SRC
**** 令dpmax[i]为以下标i元素结尾的最大乘积，dpmin[i]为以下标i元素结尾的最小乘积；
**** 对于正数，我们希望前缀乘积越大越好，dpmax[i]=max(dp[max[i-1]*nums[i],nums[i])；而对于负数，我们则希望乘上一个负数前缀来负负得正，dpmax[i]=max(dpmin[i-]*nums[i],nums[i])
*** 例题[[https://leetcode-cn.com/problems/house-robber/][198. 打家劫舍]]
#+BEGIN_SRC cpp
  int rob(vector<int>& nums) {
      if (nums.size()==1) return nums[0];
      int n = nums.size();
      vector<int> dp(n);
      dp[0] = nums[0];
      dp[1] = max(nums[0], nums[1]);
      for (int i=2; i<n; ++i) {
          dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
      }
      return dp[n-1];
  }
#+END_SRC
**** 如果取第k个，则最大金额为前k-2个的最大金额加第k个的金额；如果不取第k个，则最大金额为前k-1个的最大金额；状态转移方程为：dp[i]=max(dp[i-2]+nums[i],dp[i-1])
**** 边界条件为：当取1个时为最大金额为一个的金额，取两个时，最大金额为两个中的较大值
* 双指针
** 例题[[https://leetcode-cn.com/problems/container-with-most-water/][11. 盛最多水的容器]]
*** 代码
#+BEGIN_SRC cpp
  int maxArea(vector<int>& height) {
      int right = 0, left = height.size()-1;
      int res = 0;
      while (right<left) {
          res = max(res, min(height[right], height[left])*(left-right));
          if (height[right]<height[left]) {
              ++right;
          }
          else {
              --left;
          }
      }
      return res;
  }
#+END_SRC
**** 本题使用动态规划的时间复杂度是O(n^2)，会超时，因此使用时间复杂度为O(n)的双指针法
**** 在左右边界各放一个指针，指向较小元素的那个指针向里移动一格（只有较小元素的指针向里移动一格才有可能让容积变大，因为较大元素的指针向内移动时，边界最小值不变，宽度却缩小了）
**** 记录这个过程中容积的最大值
** 例题[[https://leetcode-cn.com/problems/3sum/][15. 三数之和]]
#+BEGIN_SRC cpp
  vector<vector<int>> threeSum(vector<int>& nums) {
      sort(nums.begin(), nums.end());
      vector<vector<int>> res;
      int n = nums.size();
      for (int i=0; i<n-2; ++i) {
          if (i>0&&nums[i]==nums[i-1]) continue; // 不能和上次数字一样
          int j = i+1;
          int k = n-1;
          int target = -nums[i];
          while (j<k) {
              if (j>i+1&&nums[j]==nums[j-1]) { // 不能和上次数字一样
                  ++j;
                  continue;
              }
              int sum = nums[j]+nums[k];
              if (sum<target) {
                  ++j;
              }
              else if (sum>target) {
                  --k;
              }
              else {
                  res.push_back({ nums[i], nums[j], nums[k] });
                  ++j; // 如果接下来还有满足条件的解，必然是一增一减
                  --k;
              }
          }
      }
      return res;
  }
#+END_SRC
*** 将数组排序
*** 第一个数字遍历数组，第二第三个数字在第一个数字之后的数字中采用双指针扫描
*** 注意避免重复情况
*** 时间复杂度O(n^2)
** 例题[[https://leetcode-cn.com/problems/next-permutation/][31. 下一个排列]]
*** 代码1
#+BEGIN_SRC cpp
  void nextPermutation(vector<int>& nums) {
      int n = nums.size();
      int i;
      for (i=n-2; i>=0; --i) {
          int temp = INT_MAX;
          int temp_i = -1;
          for (int j=i+1; j<n; ++j) {
              if (nums[j]>nums[i]&&nums[j]<temp) {
                  temp = nums[j];
                  temp_i = j;
              }
          }
          if (temp_i!=-1) {
              nums[temp_i] = nums[i];
              nums[i] = temp;
              break;
          }
      }
      sort(nums.begin()+i+1, nums.end());
#+END_SRC
**** 找到从右往左第一个有后面元素大于自己的元素，然后与大于自己的元素中最小的那个交换，然后重排后面的元素
*** 代码2（双指针）
#+BEGIN_SRC cpp
  void nextPermutation(vector<int>& nums) {
      int n = nums.size();
      int i;
      for (i=n-2; i>=0&&nums[i]>=nums[i+1]; --i);
      if (i>=0) {
          int j;
          for (j=n-1; j>i&&nums[j]<=nums[i]; --j);
          swap(nums[i], nums[j]);
      }
      reverse(nums.begin()+i+1, nums.end());
  }
#+END_SRC
**** 找到从右往左第一个小于后面元素的元素，然后再找到该元素后面从右往左第一个大于自己的元素，两者交换，并重排后面的元素
** 例题[[https://leetcode-cn.com/problems/longest-valid-parentheses/][32. 最长有效括号]]
*** 代码1
#+BEGIN_SRC cpp
  int longestValidParentheses(string s) {
      int n = s.size();
      int res = 0;
      int left = 0;
      int i = 0;
      int j = i-1;
      while (j<n-1) { // 从左往右
          ++j;
          if (s[j]=='(') {
              ++left;
          }
          else {
              --left;
          }

          if (left<0) {
              i = j+1;
              left = 0;
          }
          else if (left==0&&j-i+1>res) {
              res = j-i+1;
          }
      }

      left = 0;
      i = n-1;
      j = i+1;
      while (j>0) { // 从右往左
          --j;
          if (s[j]=='(') {
              ++left;
          }
          else {
              --left;
          }

          if (left>0) {
              i = j-1;
              left = 0;
          }
          else if (left==0&&i-j+1>res) {
              res = i-j+1;
          }
      }
      return res;
  }
#+END_SRC
**** 从左往右扫描，用变量记录左右括号数，当左右括号相等时，为有效括号，当右括号多于左括号时，重置到下一位
**** 但这种方法没办法处理"(()"这样的情况，因此从右往左反向再扫一遍
*** 代码2（动态规划）
#+BEGIN_SRC cpp
  int longestValidParentheses(string s) {
      int n = s.size();
      int maxlen = 0;
      vector<int> dp(n);
      for (int i=1; i<n; ++i) {
          if (s[i]==')'&&s[i-1]=='(') {
              dp[i] = i-2>=0?dp[i-2]+2:2;
          }
          else if (s[i]==')'&&s[i-1]==')'&&i-dp[i-1]-1>=0&&s[i-dp[i-1]-1]=='(') {
              dp[i] = dp[i-1]+(i-dp[i-1]-2>=0?dp[i-dp[i-1]-2]+2:2);
          }
          if (maxlen<dp[i]) maxlen = dp[i];
      }
      return maxlen;
  }
#+END_SRC
**** 令dp[i]为以下标i元素结尾的最长有效括号长度；遍历s
**** 若s[i]='('，则dp[i]一定为0
**** 若s[i]=')'，则
***** 当s[i-1]='('时，dp[i]=dp[i-1]+2
***** 当s[i-1]=')'时，dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2（即"a(b)"中a的长度加b的长度加2)
*** 代码3（栈）
#+BEGIN_SRC cpp
  int longestValidParentheses(string s) {
      int maxlen = 0;
      stack<int> st; 
      st.push(-1);
      for (int i=0; i<s.size(); ++i) {
          if (s[i]=='(') {
              st.push(i);
          }
          else {
              st.pop();
              if (st.empty()) {
                  st.push(i);
              }
              else {
                  maxlen = max(maxlen, i-st.top()); // 栈顶为左边最近一个未匹配括号的位置
              }
          }
      }
      return maxlen;
  }
#+END_SRC
**** 通过栈来记录左边最近一个未匹配括号的位置；
**** 遍历s；
***** 若s[i]='('则将i入栈；
***** 否则若s[i]=')'，则将栈顶元素出栈；
****** 若栈为空，则压入当前的i
****** 否则可获得以当前元素为结尾的最长有效括号的长度i-st.top()
** 例题[[https://leetcode-cn.com/problems/sort-colors/][75. 颜色分类]]
*** 代码1（单指针）
#+BEGIN_SRC cpp
  void sortColors(vector<int>& nums) {
      int n = nums.size();
      int i = 0;
      int j = i;
      while (j<n) {
          if (nums[j]==0) {
              swap(nums[i], nums[j]);
              ++i;
          }
          ++j;
      }

      j = i;
      while (j<n) {
          if (nums[j]==1) {
              swap(nums[i], nums[j]);
              ++i;
          }
          ++j;
      }
  }
#+END_SRC
**** 利用一个指针来交换0，从左往右扫描，将所有的0交换到该指针处
**** 在上一次扫描的基础上继续扫描，将所有的1交换到该指针处
*** 代码2（双指针1）
#+BEGIN_SRC cpp
  void sortColors(vector<int>& nums) {
      int n = nums.size();
      int i = 0;
      int j = 0;
      int k = j;
      while (k<n) {
          if (nums[k]==0) {
              swap(nums[i], nums[k]);
              if (i<j) {
                  swap(nums[j], nums[k]);
              }
              ++i;
              ++j;
          }
          else if (nums[k]==1) {
              swap(nums[j], nums[k]);
              ++j;
          }
          ++k;
      }
  }
#+END_SRC
**** 用两个指针，一个用来交换0，一个用来交换1
**** 1的交换同单指针方法
**** 0的交换为了防止将后面已经放好的1交换出去，因此若i<j，则和0指针交换后再和1指针交换；然后i和j同时加1
*** 代码3（双指针2）
#+BEGIN_SRC cpp
  void sortColors(vector<int>& nums) {
      int n = nums.size();
      int i = 0;
      int j = n-1;
      int k = i;
      while (k>=i&&k<=j) {
          if (nums[k]==0) {
              swap(nums[i], nums[k]);
              ++i;
              ++k;
          }
          else if (nums[k]==2) {
              swap(nums[j], nums[k]);
              --j;
              if (nums[k]==1) ++k;
          }
          else {
              ++k;
          }
      }
  }
#+END_SRC
**** 用两个指针分别从下标0和从下标n-1开始交换0和2
**** 0的交换同单指针方法
**** 2的交换需要注意的是，若交换完后的nums[k]==0或者2，则不应该k++，下一轮的交换应该还基于这个位置；否则会错过对其的交换（本质上是，从0方向交换来的元素已经扫描过了，必然不是0或2，但是从2方向交换来的元素还未扫描过，可能是0或2）
*** 代码4（个数统计）
#+BEGIN_SRC cpp
  void sortColors(vector<int>& nums) {
      int count[3] = { 0 };
      int n = nums.size();
      for (int& i : nums) {
          count[i]++;
      }

      int j = 0;
      for (int i=0; i<count[0]; ++i) {
          nums[j++] = 0;
      }
      for (int i=0; i<count[1]; ++i) {
          nums[j++] = 1;
      }
      for (int i=0; i<count[2]; ++i) {
          nums[j++] = 2;
      }
  }
#+END_SRC
**** 统计0、1和2的个数以重新生成nums
* 哈希表
** 例题[[https://leetcode-cn.com/problems/two-sum/][1. 两数之和]]
#+BEGIN_SRC cpp
  vector<int> twoSum(vector<int>& nums, int target) {
      unordered_map<int,int> map;
      for (int i=0; i<nums.size(); ++i) {
          if (map.find(target-nums[i])!=map.end()) { // 这里不能写成map[target-nums[i]=0，因为元素位置本身就有可能是0
              return { i, map[target-nums[i]] };
          }
          map[nums[i]] = i;
      }
      return { };
  }
#+END_SRC
** 例题[[https://leetcode-cn.com/problems/group-anagrams/][49. 字母异位词分组]]
*** 代码1（排序哈希）
#+BEGIN_SRC cpp
  vector<vector<string>> groupAnagrams(vector<string>& strs) {
      vector<vector<string>> res;
      unordered_map<string, vector<string>> map;
      for (string& s : strs) {
          string key = s;
          sort(key.begin(), key.end());
          map[key].emplace_back(s);
      }
      for (auto iter=map.begin(); iter!=map.end(); ++iter) {
          res.emplace_back(iter->second);
      }
      return res;
  }
#+END_SRC
**** 将排序后的数组作为哈希key
*** 代码2（计数哈希）
#+BEGIN_SRC cpp
  vector<vector<string>> groupAnagrams(vector<string>& strs) {
      auto hashfunc = [](const array<int, 26>& arr)->size_t {
          return accumulate(arr.begin(), arr.end(), 0, [](size_t acc,int a) {
              return (acc<<1)^hash<int>()(a);
          });
      };

      vector<vector<string>> res;
      unordered_map<array<int, 26>, vector<string>, decltype(hashfunc)> map(0/*初始bucket数*/, hashfunc/*哈希函数*/);
      for (string& s : strs) {
          array<int, 26> key{};
          for (char& c : s) key[c-'a']++;
          map[key].emplace_back(s);
      }
      for (auto iter=map.begin(); iter!=map.end(); ++iter) {
          res.emplace_back(iter->second);
      }
      return res;
  }
#+END_SRC
**** 创建数组array<int,26>记录每个字母出现次数，并将其作为哈希的key
** 例题[[https://leetcode-cn.com/problems/longest-consecutive-sequence/][128. 最长连续序列]]
*** 代码1（先排序）
#+BEGIN_SRC cpp
  int longestConsecutive(vector<int>& nums) {
      if (nums.size()==0) return 0;
      int res = 1;
      int count = 1;
      sort(nums.begin(), nums.end());
      for (int i=1; i<nums.size(); ++i) {
          if (nums[i]==nums[i-1]+1) {
              ++count;
              res = max(res, count);
          }
          else if (nums[i]>nums[i-1]+1) {
              count = 1;
          }
      }
      return res;
  }
#+END_SRC
*** 代码2（哈希表）
#+BEGIN_SRC cpp
  int longestConsecutive(vector<int>& nums) {
      int n = nums.size();
      int res = 0;
      unordered_map<int,int> map;
      for (int i=0; i<n; ++i) {
          map[nums[i]]++;
      }

      for (int i=0; i<n; ++i) {
          if (map[nums[i]-1]==0) { // 当x-1不存在时才进行匹配
              int j = 1;
              while (map[nums[i]+j]) j++;
              res = max(res, j);
          }
      }
      return res;
  }
#+END_SRC
**** 用哈希表加速元素查找
**** 只有不存在x-1的x，才进行常试匹配；否则肯定不会优于之前的匹配长度
* 矩阵快速幂
** 本质是把幂用二进制分解
*** 例题[[https://leetcode-cn.com/problems/climbing-stairs/][70. 爬楼梯]]
#+BEGIN_SRC C
  const int N = 10;

  int tmp[N][N];

  void multi(int a[][N], int b[][N], int n) {
      memset(tmp, 0, sizeof tmp);
      for (int i = 0; i < n; i++)
          for (int j = 0; j < n; j++)
              for (int k = 0; k < n; k++)
                  tmp[i][j] += a[i][k] * b[k][j];
      for (int i = 0; i < n; i++)
          for (int j = 0; j < n; j++)
              a[i][j] = tmp[i][j];
  }

  int res[N][N];

  void Pow(int a[][N], int n) {
      memset(res, 0, sizeof res); // n是幂，N是矩阵大小
      for (int i = 0; i < N; i++)
          res[i][i] = 1;
      while (n) {
          if (n & 1)
              multi(res, a, N); // res=res*a;复制直接在multi里面实现了；
          multi(a, a, N);       // a=a*a
          n >>= 1;
      }
  }
#+END_SRC

* 单调栈
** 栈中元素必单调，如果现准备压入的元素不符合，则弹栈到符合为止
*** 例题[[https://leetcode-cn.com/problems/largest-rectangle-in-histogram/][84. 柱状图中最大的矩形]]
**** 解法
#+BEGIN_SRC cpp
  int largestRectangleArea(vector<int>& heights) {
      int max = 0;
      int length = heights.size();
      stack<int> s;
      int* lr = new int[length];
      int* rl = new int[length];
      for(int i=0;i<length;++i) rl[i] = length;
      for(int i=0;i<length;++i) {
          while(!s.empty()&&heights[s.top()]>=heights[i]) {
              rl[s.top()] = i;
              s.pop();
          }
          if(!s.empty()) {
              lr[i] = s.top();
          }
          else {
              lr[i] = -1;
          }
          s.push(i);
      }
      for(int i=0;i<length;++i) {
          int temp = heights[i]*(rl[i]-lr[i]-1);
          if(temp>max) max = temp;
      }
      delete[] lr;
      delete[] rl;
      return max;
  }
#+END_SRC
***** 分别从左到右又从右到左遍历，通过单调栈来记录，弹栈后栈顶元素为左侧或右侧最近的小于其高度的柱子的位置，用两个数组记录
***** 优化：每次出栈，可以确定该出栈元素的右边界，即当前准备入栈元素（其为第一个可以将出栈元素出栈的元素，即右侧最近的小于其高度的柱子的位置）
*** 例题[[https://leetcode-cn.com/problems/trapping-rain-water/][42. 接雨水]]
**** 代码1（单调栈）
#+BEGIN_SRC cpp
  int trap(vector<int>& height) {
      int n = height.size();
      int res = 0;
      stack<int> st;
      for (int i=0; i<n; ++i) {
          while (!st.empty()&&height[i]>height[st.top()]) {
              int top = st.top();
              st.pop();
              if (st.empty()) break;
              res += (min(height[i], height[st.top()])-height[top])*(i-st.top()-1);
          }
          st.push(i);
      }
      return res;
  }
#+END_SRC
***** 用一个单调栈存储下标，其中下标对应的高度在单调栈中是递减的
***** 遍历heigh数组
****** 若此时单调栈中有两个及以上的元素，则弹出栈顶元素top，总面积加上(min(height[i], height[st.top()])-height[top])*(i-st.top()-1)
****** 若此时单调栈中的元素小于两个，则清空栈
***** 压入i
**** 代码2（动态规划）
#+BEGIN_SRC cpp
  int trap(vector<int>& height) {
      int n = height.size();
      int res = 0;
      vector<int> leftMax(n);
      leftMax[0] = height[0];
      vector<int> rightMax(n);
      rightMax[n-1] = height[n-1];

      for (int i=1; i<n; ++i) {
          leftMax[i] = max(leftMax[i-1], height[i]);
      }
      for (int i=n-2; i>=0; --i) {
          rightMax[i] = max(rightMax[i+1], height[i]);
      }

      for (int i=0; i<n; ++i) {
          res += min(leftMax[i], rightMax[i])-height[i];
      }

      return res;
  }
#+END_SRC
***** 易得每个位置的水量为该位置左边最大值和右边最大值中小的那个值减去当前位置的高度
***** 令leftMax[i]为i位置左边的最大值，rightMax[i]为i位置右边的最大值
***** 状态转移方程：
****** leftMax[i] = max(leftMax[i-1], height[i]);
****** rightMax[i] = max(rightMax[i+1], height[i]);
***** 计算出每个位置的水量并加和
**** 代码3（双指针）
#+BEGIN_SRC cpp
  int trap(vector<int>& height) {
      int n = height.size();
      int res = 0;
      int i = 0;
      int j = n-1;
      int leftMax = 0, rightMax = 0;
      while (i<j) {
          leftMax = max(leftMax, height[i]);
          rightMax = max(rightMax, height[j]);
          if (leftMax<rightMax) {  // 这里换成height[i]<height[j]是等价的
              res += leftMax-height[i++];
          }
          else {
              res += rightMax-height[j--];
          }
      }
      return res;
  }
#+END_SRC
***** 使用两个指针left和right从两边开始扫描，维护两个变量leftMax和rightMax，分别代表left自己及左侧最大值和right自己及右侧最大值
***** 对于两个变量中较小的那一个，可以确定其左右侧最大值中较小的值在自己这一侧；例如leftMax<rightMax，则可以确定left位置的右侧最大值一定大于左侧最大值leftMax；由此可计算出该位置的水量
***** 两边扫描直到相遇为止
**** 代码4（双向扫描）
#+BEGIN_SRC cpp
  int trap(vector<int>& height) {
      int n = height.size();
      int sum = 0;
      int i = 0;
      int j = i;
      int temp = 0;
      while (j<n) {  // 从左到右
          if (height[j]<height[i]) {
              temp += height[i]-height[j];
          }
          else {
              i = j;
              sum += temp;
              temp = 0;
          }
          ++j;
      }

      i = n-1;
      j = i;
      temp = 0;
      while (j>=0) {  // 从右到左
          if (height[j]<=height[i]) {
              temp += height[i]-height[j];
          }
          else {
              i = j;
              sum += temp;
              temp = 0;
          }
          --j;
      }
      return sum;
  }
#+END_SRC
***** j指针作为左边界，i指针作为右边界向右扫描，若低于左边界，则临时面积统计加上heigh[i]-heigh[j]，若高于左边界，则将临时面积加到面积，i指针移到j指针的位置；用这种方法可以统计到数组中所有左边界比右边界高的容器
***** 对于右边界比左边界高的容器，反向再扫描
*** 例题[[https://leetcode-cn.com/problems/maximal-rectangle/][85. 最大矩形]]
**** 代码1（暴力法）
#+BEGIN_SRC cpp
  int maximalRectangle(vector<vector<char>>& matrix) {
      int m = matrix.size();
      int n = matrix[0].size();
      int res = 0;
      vector<vector<int>> left(m, vector<int>(n));
      for (int i=0; i<m; ++i) {
          for (int j=0; j<n; ++j) {
              int pre = j>0?left[i][j-1]:0;
              left[i][j] = matrix[i][j]=='1'?pre+1:0;
          }
      }

      for (int i=0; i<m; ++i) {
          for (int j=0; j<n; ++j) {
              int width = INT_MAX;
              for (int k=i; k>=0; --k) {
                  if (left[k][j]==0) break;
                  width = min(width, left[k][j]);
                  res = max(res, width*(i-k+1));
              }
          }
      }
      return res;
  }
#+END_SRC
***** 利用left[i][j]记录(i,j)处左侧连续1的数量
***** 则对于固定j，k~i之间的最大面积为left[k][j]~left[i][j]中的最小值乘以i-k+1
**** 代码2（单调栈优化）
#+BEGIN_SRC cpp
  int maximalRectangle(vector<vector<char>>& matrix) {
      int m = matrix.size();
      int n = matrix[0].size();
      int res = 0;
      vector<vector<int>> left(m, vector<int>(n));
      for (int i=0; i<m; ++i) {
          for (int j=0; j<n; ++j) {
              int pre = j>0?left[i][j-1]:0;
              left[i][j] = matrix[i][j]=='1'?pre+1:0;
          }
      }

      vector<int> lr(m);
      vector<int> rl(m);
      for (int j=0; j<n; ++j) {
          stack<int> s;
          for(int i=0;i<m;++i) rl[i] = m;
          for(int i=0;i<m;++i) {
              while(!s.empty()&&left[s.top()][j]>left[i][j]) {
                  rl[s.top()] = i;
                  s.pop();
              }
              if(!s.empty()) {
                  lr[i] = s.top();
              }
              else {
                  lr[i] = -1;
              }
              s.push(i);
          }
          for(int i=0;i<m;++i) {
              int temp = left[i][j]*(rl[i]-lr[i]-1);
              if(temp>res) res = temp;
          }
      }
      return res;
  }
#+END_SRC
***** 在解法1的基础上，对于固定的j，求i=0~m上的最大值，方法采用类似于[[https://leetcode-cn.com/problems/largest-rectangle-in-histogram/][84. 柱状图中最大的矩形]]的方法
* 二分查找
** 模版一
*** 示例代码
#+BEGIN_SRC cpp
  int low = 0;
  int high = nums.size() - 1;
  while (low<=high) {
      int mid = (low+high)/2;
      if(nums[mid]<target) {
          low = mid + 1;
      }
      else if(nums[mid]>target) {
          high = mid - 1;
      }
      else return mid;
   }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/binary-search/][704. 二分查找]]
#+BEGIN_SRC cpp
  int search(vector<int>& nums, int target) {
      int low = 0;
      int high = nums.size() - 1;
      while (low<=high) {
          int mid = (low+high)/2;
          if(nums[mid]<target) {
              low = mid + 1;
          }
          else if(nums[mid]>target) {
              high = mid - 1;
          }
          else return mid;
      }
      return -1;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/search-insert-position/][35. 搜索插入位置]]
#+BEGIN_SRC cpp
  int searchInsert(vector<int>& nums, int target) {
      int low = 0;
      int high = nums.size() - 1;
      while (low<=high) {
          int mid = (low+high)/2;
          if(nums[mid]<target) {
              low = mid + 1;
          }
          else if(nums[mid]>target) {
              high = mid - 1;
          }
          else return mid;
      }
      return low;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/][852. 山脉数组的峰顶索引]]
#+BEGIN_SRC cpp
  int binary_search(int v[], int target) {
      int low = 0, hight = v.size() - 1;
      while (low <= high) { // <=
          int mid = (low + high) / 2;
          if (v[mid] < target)
              low = mid + 1; // mid + 1
          else if (v[mid] > target)
              high = mid - 1; // mid - 1
          else
              return mid; // 如果查找成功必定从这里走
      }
      return -1;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/search-a-2d-matrix/][74. 搜索二维矩阵]] 
*** 例题[[https://leetcode-cn.com/problems/first-bad-version/][278. 第一个错误的版本（防止计算时溢出）]]
#+BEGIN_SRC cpp
  int firstBadVersion(int n) {
      int low = 1;
      int high = n;
      while (low<=high) {
          int mid = low+(high-low)/2; // 防止计算时溢出
          if(isBadVersion(mid)) high = mid - 1;
          else low = mid + 1;
      }
      return low;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/study-plan/lcof/?progress=lynrga5][剑指 Offer 53 - I. 在排序数组中查找数字 I]]
#+BEGIN_SRC cpp
  int search(vector<int>& nums, int target) {
      int n = nums.size();
      int begin, end;
      int low = 0;
      int high = n-1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]<target)
              low = mid + 1;
          else
              high = mid - 1;
      }
      begin = low;

      low = 0;
      high = n-1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]<=target)
              low = mid + 1;
          else
              high = mid - 1;
      }
      end = low;

      return end-begin;
  }
#+END_SRC
**** 采用两次二分查找，通过二分条件的不同，分别找出第一个大于等于target的数和第一个大于target的数
*** 例题[[https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/][剑指 Offer 53 - II. 0～n-1中缺失的数字]]
#+BEGIN_SRC cpp
  int missingNumber(vector<int>& nums) {
      int low = 0;
      int high = nums.size()-1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]==mid)
              low = mid+1;
          else
              high = mid-1;
      }
      return low; //nums[low]-1 OR high+1
  }
#+END_SRC
**** 运用二分查找找到缺失元素本该在的位置，查找条件为nums[mid]==mid
** 模版二
*** 示例代码
#+BEGIN_SRC cpp
  int low = 0;
  int high = nums.size();
  while (low<high) {
      int mid = (low+high)/2;
      if(nums[mid]<target) {
          low = mid + 1;
      }
      else {
          high = mid;
      }
   }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/][153. 寻找旋转排序数组中的最小值]]
**** 解法
#+BEGIN_SRC cpp
  int findMin(vector<int>& nums) {
      int low = 0;
      int high = nums.size()-1;
      while (low<high) {
          int mid = (low+high)/2;
          if(nums[mid]>nums[high]) low = mid+1; // low可以越界
          else high = mid; // high不能越界
      } // 无序考虑nums[mid]==nums[high]的情况，因为除非low==high，否则二者不可能相等
      return nums[low];
  }
#+END_SRC
***** 作为比较基准侧的元素不可跨越边界；若以low为基准侧，则low更新法侧为low=mid，但这样当low和high相临时，由于整型的向下取整原则，low会止步不前；因此取用high为基准侧较好
*** 例题[[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/submissions/][154. 寻找旋转排序数组中的最小值 II]]
**** 解法一
#+BEGIN_SRC cpp
  int findMin(vector<int>& nums) {
      int low = 0;
      int high = nums.size()-1;
      while (low<high) {
          int mid = (low+high)/2;
          if(nums[mid]>nums[high]) low = mid+1;
          else if(nums[mid]<nums[high]) high = mid;
          else high--; // 此处区别于153
      }
      return nums[low];
  }
#+END_SRC
***** 与153的区别在于需要处理nums[mid]==nums[high]的情况；当nums[mid]==nums[high]时，若high为最小值，则有不止一个最小值，high左移一位也不会跨过中界，若high不是最小值，则更不会跨过中界，因此可放心左移
**** 解法二
#+BEGIN_SRC cpp
  int findMin(vector<int>& nums) {
      int low = 0;
      int high = nums.size()-1;
      while (low<high) {
          int mid = (low+high)/2;
          if(nums[mid]>nums[high]) low = mid+1;
          else if((nums[mid]==nums[high]&&nums[low]!=nums[high])||nums[mid]<nums[high]) high = mid;
          else {
              high--;
              low++;
          }
      }
      return nums[low];
  }
#+END_SRC
***** 可以再细分情况，当nums[mid]==nums[high]时，如果nums[low]!=nums[high]，那么依旧可以判断出mid和high同一侧，否则若nums[low]==nums[high]，则low和high可以同时向内收缩一步，不会影响到取值范围
*** 例题[[https://leetcode-cn.com/problems/search-in-rotated-sorted-array/][33. 搜索旋转排序数组]]
**** 官方题解
#+BEGIN_SRC cpp
  int search(vector<int>& nums, int target) {
      int n = (int)nums.size();
      if (!n) {
          return -1;
      }
      if (n == 1) {
          return nums[0] == target ? 0 : -1;
      }
      int l = 0, r = n - 1;
      while (l <= r) {
          int mid = (l + r) / 2;
          if (nums[mid] == target) return mid;
          if (nums[0] <= nums[mid]) {
              if (nums[0] <= target && target < nums[mid]) {
                  r = mid - 1;
              } else {
                  l = mid + 1;
              }
          } else {
              if (nums[mid] < target && target <= nums[n - 1]) {
                  l = mid + 1;
              } else {
                  r = mid - 1;
              }
          }
      }
      return -1;
  }
#+END_SRC
***** 官方题解本质上是对二分查找进行了两层判断；首先第一层判断mid落在最小值的左边还是右边（因为不同情况对应的第二层判断不一样）；而后第二层判断是判断target落在mid的左测还是右侧；
**** 我的题解
#+BEGIN_SRC cpp
  int search(vector<int>& nums, int target) {
      int low = 0;
      int high = nums.size()-1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]==target) return mid;
          if (nums[low]<=nums[mid]) {
              if (nums[low]<=target && nums[mid]>target) {
                  high = mid-1;
              }
              else {
                  low = mid+1;
              }
          }
          else {
              if (nums[high]>=target && nums[mid]<target) {
                  low = mid+1;
              }
              else {
                  high = mid-1;
              }
          }
      }
      return -1;
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/][81. 搜索旋转排序数组 II]]
**** 题解一
#+BEGIN_SRC cpp
  bool search(vector<int>& nums, int target) {
      int low = 0;
      int high = nums.size()-1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]==target) return true;
          if (nums[low]<nums[mid]) {
              if (nums[low]<=target && nums[mid]>target) {
                  high = mid-1;
              }
              else {
                  low = mid+1;
              }
          }
          else if (nums[low]>nums[mid]) {
              if (nums[high]>=target && nums[mid]<target) {
                  low = mid+1;
              }
              else {
                  high = mid-1;
              }
          }
          else {
              low++; // 这是重点
          }
      }
      return false;
  }
#+END_SRC
***** 参考154的方法对33的题解进行改造，增加对nums[low]==nums[mid]的处理即可得到81的题解
**** 题解二
#+BEGIN_SRC cpp
  bool search(vector<int>& nums, int target) {
      int low = 0;
      int high = nums.size()-1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]==target) return true;
          if ((nums[low]==nums[mid]&&nums[low]!=nums[high])||nums[low]<nums[mid]) {
              if (nums[low]<=target && nums[mid]>target) {
                  high = mid-1;
              }
              else {
                  low = mid+1;
              }
          }
          else if (nums[low]>nums[mid]) {
              if (nums[high]>=target && nums[mid]<target) {
                  low = mid+1;
              }
              else {
                  high = mid-1;
              }
          }
          else {
              low++;
              high--;
          }
      }
      return false;
  }
#+END_SRC
***** 当nums[low]==nums[mid]时，如果nums[low]!=nums[high]，则依旧说明mid和low在同一侧，按同一侧处理，如果nums[low]==nums[high]，则low和high可以同时向内收缩一步，不会影响到取值范围
** 其余
*** 例题[[https://leetcode-cn.com/problems/median-of-two-sorted-arrays/][4. 寻找两个正序数组的中位数]]
**** 代码1（前缀比较排除）
#+BEGIN_SRC cpp
  class Solution {
  public:
      double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
          int m = nums1.size();
          int n = nums2.size();
          if ((m+n)%2) {
              return getK(nums1, nums2, (m+n+1)/2);
          }
          else {
              return (getK(nums1, nums2, (m+n)/2)+getK(nums1, nums2, (m+n)/2+1))/2.0;
          }
      }
      int getK(vector<int>& nums1, vector<int>& nums2, int k) {
          int m = 0;
          int n = 0;
          while (k>1&&m<nums1.size()&&n<nums2.size()) {
              int k1 = k/2-1+m<nums1.size()?k/2-1:nums1.size()-1-m;
              int k2 = k/2-1+n<nums2.size()?k/2-1:nums2.size()-1-n;
              if (nums1[k1+m]<=nums2[k2+n]) {
                  m = k1+m+1;
                  k = k-k1-1;
              }
              else {
                  n = k2+n+1;
                  k = k-k2-1;
              }
          }
          if (m>=nums1.size()) {
              return nums2[n+k-1];
          }
          else if (n>=nums2.size()) {
              return nums1[m+k-1];
          }
          else {
              return min(nums1[m], nums2[n]);
          }
      }
  };
#+END_SRC
***** 设两个数组的大小分别为m和n，则如果m+n为奇数，则其中位数为第(m+n)/2+1个元素，如果m+n为偶数，则其中位数为第(m+n)/2和第(m+n)/2+1个元素的平均值
***** 令函数getK为获取两个数组的第k个元素，则可以用如下类二分的方法查找
***** 比较nums1[k/2-1]和nums2[k/2-1]的大小，若nums1[k/2-1]<=nums2[k/2-1]，则nums1[0...k/2-1]都可以被排除；若k/2-1越界，则采用数组的最后一个元素参与判断；直到出现如下情况：
****** 任一数组为空，则返回另一个数组的[k-1]
****** k为1，则返回两个数组头元素中较小的那一个
**** 代码2（二分搜索符合条件的i）
#+BEGIN_SRC cpp
  /*      left_part          |         right_part
   ,*A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
   ,*B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
   ,*/
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
      int m = nums1.size();
      int n = nums2.size();
      if (m>n) return findMedianSortedArrays(nums2, nums1);
      int low = 0;
      int high = m; // 为什么是m？因为要做到两种情况，元素全在左边或元素全在右边
      while (low<=high) {
          int i = (low+high)/2;
          int j = (m+n+1)/2-i;
          if (i==0||j==n||nums1[i-1]<=nums2[j]) {
              low = i+1;
          }
          else {
              high = i-1;
          }
      }
      int i = high;
      int j = (m+n+1)/2-i;
      if ((m+n)%2) {
          return max(i==0?INT_MIN:nums1[i-1], j==0?INT_MIN:nums2[j-1]);
      }
      else {
          return (max(i==0?INT_MIN:nums1[i-1], j==0?INT_MIN:nums2[j-1])+min(i==m?INT_MAX:nums1[i], j==n?INT_MAX:nums2[j]))/2.0;
      }
  }
#+END_SRC
***** 通过i和j将两个数组分为两个部分，其中i可取[0,m]，而j=(m+n+1)/2-i；通过二分查找找到满足A[i-1]<=B[j]且B[j-1]<=A[i]的i（不需要A[i-1]<=A[i]和B[i-1]<=B[i]，因为二者本来就是有序的）；
***** 实际上只需找到最大的i满足A[i-1]<=B[j]即可
***** 取A[-1]=B[-1]=INT_MIN，A[m]=A[n]=INT_MAX
***** 最终，若m+n为奇数，取中位数为max(A[i-1],B[j-1])；若m+n为偶数，则取中位数为(max(A[i-1],B[j-1])+min(A[i],B[j]))/2.0
*** 例题[[https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/][34. 在排序数组中查找元素的第一个和最后一个位置]]
#+BEGIN_SRC cpp
  vector<int> searchRange(vector<int>& nums, int target) {
      int n = nums.size();
      int low = 0;
      int high = n-1;
      int begin = -1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]<target) {
              low = mid+1;
          }
          else {
              high = mid-1;
          }
      }
      if (low<n&&nums[low]==target) begin = low;
      else return {-1, -1};

      low = 0;
      high = n-1;
      int end = -1;
      while (low<=high) {
          int mid = (low+high)/2;
          if (nums[mid]<=target) {
              low = mid+1;
          }
          else {
              high = mid-1;
          }
      }
      if (high>=0&&nums[high]==target) end = high;
      return { begin, end };
  }
#+END_SRC
**** 两次二分查找
* 链表
** 例题[[https://leetcode-cn.com/problems/reverse-linked-list-ii/][92. 反转链表 II]]
*** 头插法适合用来反转链表
** 例题[[https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/][剑指 Offer 35. 复杂链表的复制]]
*** 代码1（哈希表）
#+BEGIN_SRC cpp
  Node* copyRandomList(Node* head) {
      unordered_map<Node*,Node*> map;
      Node* dummy = new Node(0);
      Node* pre = dummy;
      while (head) {
          Node* copy = map[head];
          if (!copy) {
              copy = new Node(head->val);
              map[head] = copy;
          }
          if (head->random) {
              Node* random = map[head->random];
              if (!random) {
                  random = new Node(head->random->val);
                  map[head->random] = random;
              }
              copy->random = random;
          }
          pre->next = copy;
          pre = copy;
          head = head->next;
      }
      return dummy->next;
  }
#+END_SRC
**** 利用哈希表来记录创建过的节点，如果当前所需节点未创建则创建，如果已经创建则连接上指针
*** 代码2（节点拼接）
#+BEGIN_SRC cpp
  Node* copyRandomList(Node* head) {
      Node* dummy = new Node(0);
      dummy->next = head;
      while (head) {
          Node* copy = new Node(head->val);
          copy->next = head->next;
          head->next = copy;
          head = head->next->next;
      }
      head = dummy->next;
      while (head) {
          if (head->random)
              head->next->random = head->random->next;
          head = head->next->next;
      }
      head = dummy->next;
      Node* pre = dummy;
      while (head) {
          pre->next = head->next;
          head->next = head->next->next;
          pre = pre->next;
          head = head->next;
      }
      return dummy->next;

  }
#+END_SRC
**** 进行三次循环，第一次把每个新节点插在旧节点之后，第二次连上每个新节点的random，第三次将新节点拆出形成新链表
** 例题[[https://leetcode-cn.com/study-plan/lcof/?progress=lynrga5][剑指 Offer 06. 从尾到头打印链表]]
** 例题[[https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/][19. 删除链表的倒数第 N 个结点]]
*** 代码1（队列法）
#+BEGIN_SRC cpp
  ListNode* removeNthFromEnd(ListNode* head, int n) {
      queue<ListNode*> qu;
      ListNode* dummy = new ListNode(0, head);
      qu.push(dummy);
      while (head) {
          qu.push(head);
          if (qu.size()>n+1) {
              qu.pop();
          }
          head = head->next;
      }
      ListNode* pre = qu.front();
      qu.pop();
      ListNode* cur = qu.front();
      pre->next = cur->next;
      return dummy->next;
  }
#+END_SRC
*** 代码2（快慢指针）
#+BEGIN_SRC cpp
  ListNode* removeNthFromEnd(ListNode* head, int n) {
      ListNode* dummy = new ListNode(0, head);
      ListNode *slow = dummy, *fast = dummy;
      int count = 0;
      while (fast) {
          fast = fast->next;
          if (count==n+1) // 因为fast最终将指向null，所以应该是n+1
              slow = slow->next;
          else
              count++;
      }
      slow->next = slow->next->next;
      return dummy->next;
  }
#+END_SRC
**** 令快指针比慢指针令先n个元素（实际是n+1个）
** 例题[[https://leetcode-cn.com/problems/intersection-of-two-linked-lists/][160. 相交链表]]
#+BEGIN_SRC cpp
  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
      ListNode* curA = headA;
      ListNode* curB = headB;
      while (curA!=curB) {
          if (curA) {
              curA = curA->next;
          }
          else {
              curA = headB;
          }
          if (curB) {
              curB = curB->next;
          }
          else {
              curB = headA;
          }
      }
      return curA;
  }
#+END_SRC
*** 令链表A的长度为m，链表B的长度为n；若两者相交，令链表A不相交部分的长度为a，链表b不相交部分的长度为b，两者相交部分的长度为c，则m=a+c，n=b+c
*** 用两个指针分别指向链表A和链表b的开头，并且每次同时向后移动一步；当A指针为空时，移动到链表B的头节点，当B指针为空时，移动到链表A的头节点
*** 若链表相交，则两者将在a+b+c步相遇；若链表不相交，则两者将在m+n步同时为空
* 数组
** 例题[[https://leetcode-cn.com/problems/merge-intervals/][56. 合并区间]]
#+BEGIN_SRC cpp
  vector<vector<int>> merge(vector<vector<int>>& intervals) {
      int n = intervals.size();
      sort(intervals.begin(), intervals.end());
      vector<vector<int>> res;
      for (auto& pair : intervals) {
          if (!res.empty()&&pair[0]<=res.back()[1]) {
              res.back()[1] = max(res.back()[1], pair[1]);
          }
          else {
              res.emplace_back(pair);
          }
      }
      return res;
  }
#+END_SRC
*** 将区间数组按照左边界递增排列
*** 从左往右遍历每个区间
**** 若该区间的左端点小于结果数组最后一个区间的右端点（即两区间重叠），则用该区间的右端点更新最后一个区间的右端点（如果该区间右端点更大的话）
**** 否则将该区间加入结果数组末尾
** 例题[[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/][121. 买卖股票的最佳时机]]
#+BEGIN_SRC cpp
  int maxProfit(vector<int>& prices) {
      int pmin = INT_MAX;
      int res = 0;
      for (int p : prices) {
          if (p<pmin) {
              pmin = p;
          }
          else {
              res = max(res, p-pmin);
          }
      }
      return res;
  }
#+END_SRC
*** 记录历史最小值
** 例题[[https://leetcode.cn/problems/product-of-array-except-self/][238. 除自身以外数组的乘积]]
*** 代码1（双数组）
#+BEGIN_SRC cpp
  vector<int> productExceptSelf(vector<int>& nums) {
      int length = nums.size();
      vector<int> l(length), r(length), res(length);
      for (int i=0; i<length; ++i) {
          l[i] = i==0?1:nums[i-1]*l[i-1];
      }
      for (int i=length-1; i>=0; --i) {
          r[i] = (i==length-1)?1:nums[i+1]*r[i+1];
      }
      for (int i=0; i<length; ++i) {
          res[i] = l[i]*r[i];
      }
      return res;
  }
#+END_SRC
**** 用两个数组分别记录左侧加和于右侧加和
*** 代码2（O(1)空间优化）
#+BEGIN_SRC cpp
  vector<int> productExceptSelf(vector<int>& nums) {
      int length = nums.size();
      vector<int> res(length);
      for (int i=0; i<length; ++i) {
          res[i] = i==0?1:nums[i-1]*res[i-1];
      }
      int r = 1;
      for (int i=length-2; i>=0; --i) {
          r *= nums[i+1];
          res[i] *= r;
      }
      return res;
  }
#+END_SRC
*** 代码3
#+BEGIN_SRC cpp
  vector<int> productExceptSelf(vector<int>& nums) {
      vector<int> ret = vector(nums.size(), 1);
      int front = 1;
      int back = 1;
      int num_size = nums.size();
      for (int i = 1; i < num_size; ++i) {
          front   *= nums[i - 1];
          back    *=  nums[num_size - i];
          ret[i]  *= front;
          ret[num_size - i - 1] *= back;
      }
      return ret;
  }
#+END_SRC
* sort() vs stable_sort()
** sort()排序后相等元素次序可能会发生改变，stable_sort()不会
** ab为true，ba或a=b为false 
* 先序遍历
** 递归
** 迭代
** 例题[[https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/][114. 二叉树展开为链表]]
*** 代码1（递归）
#+BEGIN_SRC cpp
  void flatten(TreeNode* root) {
      preorderTraversal(root);
  }
  TreeNode* preorderTraversal(TreeNode* root) {
      if (!root) return  nullptr;
      TreeNode* right = root->right;
      TreeNode* left = root->left;
      root->left = nullptr;
      if (left) {
          root->right = left;
          left = preorderTraversal(left);
      }
      else {
          left = root;
      }

      if (right) {
          left->right = right;
          right = preorderTraversal(right);
      }
      else {
          right = left;
      }
      return right;
  }
#+END_SRC
*** 代码2（迭代）
#+BEGIN_SRC cpp
  void flatten(TreeNode* root) {
      stack<TreeNode*> st;
      TreeNode* cur = root;
      TreeNode* pre = nullptr;
      while (cur||!st.empty()) {
          if (cur) {
              st.push(cur);
              pre = cur;
              TreeNode* right = cur->right;
              cur->right = cur->left;
              cur->left = right;
              cur = cur->right;
          }
          else {
              cur = st.top()->left;
              st.top()->left = nullptr;
              st.pop();
              pre->right = cur;
          }
      }
  }
#+END_SRC
*** 代码3（寻找前驱节点）
#+BEGIN_SRC cpp
  void flatten(TreeNode* root) {
      TreeNode* cur = root;
      while (cur) {
          TreeNode* left = cur->left;
          if (left) {
              while (left->right) left = left->right;
              left->right = cur->right;
              cur->right = cur->left;
              cur->left = nullptr;
          }
          cur = cur->right;
      }
  }
#+END_SRC
**** 对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空；对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束
* 中序遍历
** 递归
** 迭代
*** 例题[[https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/][94. 二叉树的中序遍历]]
**** Morris遍历算法（能使空间复杂度为O(1)）：
1. 如果x无左孩子，则访问自身，然后x=x.right
2. 如果x有左孩子，则迭代获得其左子数的最右节点，若
   1) 左子树最右节点的右孩子为空，则将其右孩子指向x，然后x=x.left
   2) 左子数最右节点的右孩子为x，则将其右孩子指向null，然后访问x自身，并x=x.right
3. 重复上述步骤，直到访问完整棵树
#+BEGIN_SRC cpp
  // Morris遍历算法
  vector<int> inorderTraversal(TreeNode *root) {
      vector<int> res;
      while (root) {
          if (root->left == nullptr) {
              res.push_back(root->val);
              root = root->right;
          } else {
              TreeNode *temp = root->left;
              while (temp->right && temp->right != root) {
                  temp = temp->right;
              }
              if (temp->right == nullptr) {
                  temp->right = root;
                  root = root->left;
              } else {
                  temp->right = nullptr;
                  res.push_back(root->val);
                  root = root->right;
              }
          }
      }
      return res;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/validate-binary-search-tree/][98. 验证二叉搜索树]]
**** 代码
#+BEGIN_SRC cpp
  bool isValidBST(TreeNode* root) {
      stack<TreeNode*> st;
      long long pre = (long long)INT_MIN-1;
      while (root || !st.empty()) {
          if(root) {
              st.push(root);
              root = root->left;
          }
          else {
              root = st.top();
              st.pop();
              if(pre>=root->val) return false;
              pre = root->val;
              root = root->right;
          }
      }
      return true;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/][105. 从前序与中序遍历序列构造二叉树]]
**** 代码1（递归）
#+BEGIN_SRC cpp
  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      if (preorder.size()==0) return nullptr;
      TreeNode* root = new TreeNode(preorder[0]);
      auto iter = find(inorder.begin(), inorder.end(), preorder[0]);
      vector<int> inorder_left(inorder.begin(), iter);
      vector<int> inorder_right(iter+1, inorder.end());
      vector<int> preorder_left(preorder.begin()+1, preorder.begin()+1+inorder_left.size());
      vector<int> preorder_right(preorder.begin()+1+inorder_left.size(), preorder.end());
      root->left = buildTree(preorder_left, inorder_left);
      root->right = buildTree(preorder_right, inorder_right);
      return root;
  }
#+END_SRC
***** 通过前序和中序遍历序列，分别找出二叉树根节点左子树和右子树的前序和中序遍历序列；递归创建左右子树
**** 代码2（迭代）
#+BEGIN_SRC cpp
  TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      int n = preorder.size();
      stack<TreeNode*> st;
      int i = 0;
      int j = 0;
      TreeNode* root = new TreeNode(preorder[i]);
      st.push(root);
      ++i;
      TreeNode* pre = nullptr; 
      while (i<n) {
          if (!st.empty()&&st.top()->val==inorder[j]) {
              pre = st.top();
              st.pop();
              ++j;
          }
          else {
              if (pre) {
                  TreeNode* temp = new TreeNode(preorder[i]);
                  pre->right = temp;
                  st.push(temp);
                  pre = nullptr;
              }
              else {
                  TreeNode* temp = new TreeNode(preorder[i]);
                  st.top()->left = temp;
                  st.push(temp);
              }
              ++i;
          } 
      }
      return root;
  }
#+END_SRC
***** 遍历前序序列
***** 用一个栈记录还未插入右孩子的节点，用一个指针指向中序遍历序列中的元素，表示当前节点向左访问能到达的最左节点
***** 当栈顶元素等于指针指向的中序序列元素时，表名现在到达当前子树的最左边，则弹出栈顶元素，中序序列指针加一
***** 否则，如果上一步操作是弹出栈顶元素，则将当前前序序列元素作为上一次弹出元素的右孩子；若上一次不是弹出，则将当前前序序列元素作为栈顶元素的左孩子
***** 将当前前序元素压入栈
* 后序遍历
** 递归
** 迭代
* 二叉搜索树
** 例题
*** 例题[[https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/][701. 二叉搜索树中的插入操作]]
**** 递归
#+BEGIN_SRC cpp
  TreeNode* insertIntoBST(TreeNode* root, int val) {
      if(!root) return new TreeNode(val);
      if(root->val>val) root->left = insertIntoBST(root->left,val);
      else root->right = insertIntoBST(root->right,val);
      return root;
  }
#+END_SRC
**** 迭代
#+BEGIN_SRC cpp
  TreeNode* insertIntoBST(TreeNode* root, int val) {
      if(!root) return new TreeNode(val);
      TreeNode* temp = root;
      while(temp) {
          if(temp->val>val) {
              if(temp->left)
                  temp = temp->left;
              else {
                  temp->left = new TreeNode(val);
                  break;
              }
          }
          else {
              if(temp->right)
                  temp = temp->right;
              else {
                  temp->right = new TreeNode(val);
                  break;
              }
          }
      }
      return root;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/delete-node-in-a-bst/][450. 删除二叉搜索树中的节点]]
**** 代码1
#+BEGIN_SRC cpp
  TreeNode* deleteNode(TreeNode* root, int key) {
      TreeNode* dummy = new TreeNode(0, root, nullptr);
      TreeNode* pre = dummy;
      while (root) {
          if (root->val>key) {
              pre = root;
              root = root->left;
          }
          else if (root->val<key) {
              pre = root;
              root = root->right;
          }
          else {
              if (root->left) {
                  root->val = getMost(root->left, 1);
                  root->left = deleteNode(root->left, root->val);
              }
              else if (root->right) {
                  root->val = getMost(root->right, 0);
                  root->right = deleteNode(root->right, root->val);
              }
              else {
                  if (pre->right&&pre->right->val==key) pre->right = nullptr;
                  else if (pre->left&&pre->left->val==key) pre->left = nullptr;
              }
              break;
          }
      }
      return dummy->left;
  }

  int getMost(TreeNode* root, int LR) {
      if (LR==0) {
          while (root->left) {
              root = root->left;
          }
      }
      else {
          while (root->right) {
              root = root->right;
          }
      }
      return root->val;
  }
#+END_SRC
通过对二叉树进行遍历找到待删除的元素，如果它没有左右子树，则直接将其删除，如果它有左右子树，则将其替换为它的前驱或者后继，并且对其左子树或右子树递归调用此函数，删除前驱或者后继节点
**** 代码2
#+BEGIN_SRC cpp
  TreeNode* deleteNode(TreeNode* root, int key) {
      if (!root) return nullptr;
      if (root->val<key) {
          root->right = deleteNode(root->right, key);
      }
      else if (root->val>key) {
          root->left = deleteNode(root->left, key);
      }
      else {
          if (root->left&&root->right) {
              TreeNode* cur = root->right;
              while (cur->left) {
                  cur = cur->left;
              }
              cur->left = root->left;
              return root->right;
          }
          else if (root->left) {
              return root->left;
          }
          else {
              return root->right;
          }
      }
      return root;
  }
#+END_SRC
若当前节点不等于key，自顶向下对左右子树调用删除函数，返回处理过后的子树根节点；若节点等于key，当左右子树不同时存在时，返回左子树或右子树根节点以替代当前节点，当左右子树不存在时，返回nullptr，当左右子树都存在时，返回右子树根节点以替带当前节点，并将左子树挂接到当前节点的后继节点的左侧
*** 例题[[https://leetcode-cn.com/problems/balanced-binary-tree/][110. 平衡二叉树]]
* 回文数
** 反转一半数字
#+BEGIN_SRC cpp
  bool isPalindrome(int x) {
      // 特殊情况：
      // 如上所述，当 x < 0 时，x 不是回文数。
      // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
      // 则其第一位数字也应该是 0
      // 只有 0 满足这一属性
      if (x < 0 || (x % 10 == 0 && x != 0)) {
          return false;
      }

      int revertedNumber = 0;
      while (x > revertedNumber) {
          revertedNumber = revertedNumber * 10 + x % 10;
          x /= 10;
      }

      // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
      // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
      // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
      return x == revertedNumber || x == revertedNumber / 10;
  }
#+END_SRC
* 二进制
** 二进制逐位累加
*** 例题[[https://leetcode-cn.com/problems/single-number-ii/][137. 只出现一次的数字 II]]
** x&-x或者(x&(x-1))^x可以获得二进制下x不是0的最低位
*** 例题[[https://leetcode-cn.com/problems/single-number-iii/][260. 只出现一次的数字 III]]
#+BEGIN_SRC cpp
  vector<int> singleNumber(vector<int>& nums) {
      int a = 0;
      int b = 0;
      int x = 0;
      for(int i=0;i<nums.size();++i) {
          x ^= nums[i];
      }
      x = (x==INT_MIN)?x:x&-x; //仅当x=INT_MIN时会溢出，且此时最低不为0的位为符号位，无需变换
      for(int i=0;i<nums.size();++i) {
          if(nums[i]&x) a ^= nums[i];
          else b ^= nums[i];
      }
      return vector<int>{a,b};
  }
#+END_SRC
** n&(n-1)相当于将二进制下x最低位的1置0
*** 例题[[https://leetcode-cn.com/problems/number-of-1-bits/][191. 位1的个数]]
#+BEGIN_SRC cpp
  int hammingWeight(uint32_t n) {
      int res = 0;
      while (n) {
          n = n&(n-1);
          res++;
      }
      return res;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/counting-bits/][338. 比特位计数]] 
** 颠倒二进制位
*** 例题[[https://leetcode-cn.com/problems/reverse-bits/][190. 颠倒二进制位]]
* 快速排序
** 时间复杂度O(nlogn)~O(n^2)
** 流程
*** 若元素数量大于1,将第一个元素拿出用做基准元素，头和尾分别设一个指针，尾指针先移动，如果遇到比基准元素小的，则将其拿给头指针，然后头指针移动，遇到大于等于基准元素的，将其拿给尾指针，如此交替，直到两个指针相遇为止；将基准值赋给相遇点
*** 将相遇点左侧和右侧的区间递归调用步骤1
** 代码
#+BEGIN_SRC cpp
  void quicksort(int *s, int x, int y) {
      if (x >= y)
          return;
      int begin = x;
      int end = y;
      int bend = 1;
      int base = s[begin];
      while (begin < end) {
          if (bend) {
              if (s[end] >= base) {
                  end--;
              } else {
                  s[begin] = s[end];
                  bend = 0;
              }
          } else {
              if (s[begin] < base) {
                  begin++;
              } else {
                  s[end] = s[begin];
                  bend = 1;
              }
          }
      }
      s[begin] = base;

      quicksort(s, x, begin - 1);
      quicksort(s, begin + 1, y);
  }
#+END_SRC
* 堆排序
** 时间复杂度O(nlogn)
** 流程
*** 从最后一个非叶子节点(length/2-1)开始向前调整
*** 对每个非叶子节点，若其左右孩子中大的那个大于自身，则将其赋值自身，然后将那个孩子节点当做当前非叶子节点继续向下判断，直到其为叶子节点或者左右孩子都比自身小，此时将最初始叶子节点的值赋予当前节点
*** 以上步骤完成后，可建立一个大顶堆
*** 将大顶堆的最大一个元素（元素0)与末尾元素交换位置，然后忽略掉末尾元素
*** 此时只有元素0太小而不符合大顶堆，因此对元素0调用步骤2,将其沉到末尾，又形成一个大顶堆
*** 回到步骤4，不断重复，直到所有节点有序
** 本质是构造大顶堆，取出最大元素，然后再不断调整大顶堆，每次都萃取出最大元素
** 代码
#+BEGIN_SRC cpp
  void adjust(int *s, int i, int length)
  {
      int temp = s[i];
      int k = i*2+1;
      while (k<length) {
          if (k+1<length&&s[k+1]>s[k]) {
              k = k+1;
          }
          if (s[k]>temp) {
              s[i] = s[k];
              i = k;
              k = k*2+1;
          }
          else break;
      }
      s[i] = temp;
  }

  void heapsort(int *s, int length)
  {
      for (int i=length/2-1; i>=0; --i) {
          adjust(s, i, length);
      } 
      for (int i=length-1; i>0; --i) {
          int temp = s[0];
          s[0] = s[i];
          s[i] = temp;
          adjust(s, 0, i);
      }
  }
#+END_SRC
** 例题[[https://leetcode.cn/problems/kth-largest-element-in-an-array/][215. 数组中的第K个最大元素]]
* 归并排序
** 时间复杂度O(nlogn)
** 流程
*** 将待排序链表分成两份，分别递归进行归并排序，排序后的两个结果链表再进行如下归并
*** 先建立一个链表头作为结果链表
*** 比较两个待排序链表的头节点值大小，较小（大）的赋给结果链表头的next指针；然后赋值的链表指针指向next，结果链表也指向next；如此循环，直到两个待排序链表其中一个为空
*** 将非空的待排序链表接在结果链表后面
*** 例题[[https://leetcode-cn.com/problems/sort-list/][148. 排序链表]]
**** 自顶向下
#+BEGIN_SRC cpp
  ListNode* sortList(ListNode* head) {
      if(!head||!head->next) return head;
      ListNode* a = head;
      ListNode* b = head->next;
      while (b->next) {
          a = a->next;
          b = b->next;
          if (b->next) {
              b = b->next;
          }
      }
      b = a->next;
      a->next = nullptr;
      a = head;

      a = sortList(a);
      b = sortList(b);
      a = mergeTwoLists(a,b);
      return a;
  }

  ListNode* mergeTwoLists(ListNode* l1,ListNode* l2)
  {
      ListNode* head = new ListNode;
      ListNode* temp = head;
      while(l1&&l2){
          if(l1->val<l2->val){
              temp->next = l1;
              l1 = l1->next;
          }
          else {
              temp->next = l2;
              l2 = l2->next;
          }
          temp = temp->next;
      }
      if(l1) temp->next = l1;
      if(l2) temp->next = l2;
      return head->next;
  }
#+END_SRC
**** 自底向上（O(1)空间复杂度）
#+BEGIN_SRC cpp
  // O(1)空间复杂度
  ListNode* sortList(ListNode* head) {
      int length = 0;
      ListNode* temp = head;
      while (temp) {
          temp = temp->next;
          length++;
      }
      ListNode* dummy = new ListNode(0,head);
      for (int sublength=1; sublength<length; sublength*=2) { // 各种不同长度分段
          ListNode* pre = dummy;
          ListNode* cur = dummy->next;
          while (cur) { // 从头开始遍历
              int i = 0;
              ListNode* head1 = cur;
              while (cur&&(++i)<sublength) { // 第一段
                  cur = cur->next;
              }
              ListNode* head2 = nullptr;
              if (cur) {                     // 如果第一段提前结尾
                  head2 = cur->next;
                  cur->next = nullptr;
              }
              cur = head2;
              i = 0;

              while (cur&&(++i)<sublength) { // 第二段
                  cur = cur->next;
              }
              ListNode* next = nullptr;
              if (cur) {                     // 如果第二段提前结尾
                  next = cur->next;
                  cur->next = nullptr;
              }
              pre->next = mergeTwoLists(head1, head2); // 归并

              while (pre->next) {
                  pre = pre->next;
              }
              cur = next;
          }
      }
      return dummy->next;
  }

  ListNode* mergeTwoLists(ListNode* l1,ListNode* l2)
  {
      ListNode* head = new ListNode;
      ListNode* temp = head;
      while(l1&&l2){
          if(l1->val<l2->val){
              temp->next = l1;
              l1 = l1->next;
          }
          else {
              temp->next = l2;
              l2 = l2->next;
          }
          temp = temp->next;
      }
      if(l1) temp->next = l1;
      if(l2) temp->next = l2;
      return head->next;
  }
#+END_SRC
** 哑节点
* 贪心
** 例题
*** 例题[[https://leetcode-cn.com/problems/jump-game/][55. 跳跃游戏]]
*** 例题[[https://leetcode-cn.com/problems/jump-game-ii/][45. 跳跃游戏 II]] 
#+BEGIN_SRC cpp
  int jump(vector<int>& nums) {
      int n = nums.size();
      int count = 0;
      int max_dis = 0;
      int dis = min(nums[0],n-1);
      for (int i=1; i<n; ++i) {
          max_dis = max(max_dis,i+nums[i]);
          if (i==dis) {
              dis = min(max_dis,n-1);
              count++;
          }
      }
      return count;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/longest-increasing-subsequence/][300. 最长递增子序列]]
**** 流程
***** 遍历nums数组，数组d[i]为当前遍历时刻，长度为i的上升序列中结尾最小的值，而len为当前最长上升子序列，起始时len为1,d[1]=nums[0]；
***** 对于nums[i]，如果nums[i]>d[len]，则len=len+1，d[len]=nums[i]；若nums[i]<=d[len]，则使用二分查找在[1,len-1]中找到最大的一个j满足d[j]<nums[i]，然后令d[j+1]=nums[i]；
***** 最终遍历结束时的len为最长上升子序列的长度
**** 代码
#+BEGIN_SRC cpp
  int lengthOfLIS(vector<int>& nums) {
      int n = nums.size();
      int len = 1;
      vector<int> d(n+1, nums[0]);
      for (int i=1; i<n; ++i) {
          if (nums[i]>d[len]) {
              len++;
              d[len] = nums[i];
          }
          else {
              int low = 1;
              int high = len;
              while (low<=high) {
                  int mid = (low+high)/2;
                  if (d[mid]<nums[i]) low = mid+1;
                  else high = mid-1;
              }
              d[high+1] = nums[i]; // 从之前的查找可知，d[high]之后到d[len]之前的都比nums[i]大
          }
      }
      return len;
  }
#+END_SRC
* 回溯法
** 时间复杂度O(n!)
** 流程
*** 回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。时间复杂度一般 O(n!)，它不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高
** 代码
#+BEGIN_SRC cpp
  void backtrack(string &s, int i) {
      if(is_end(i)) {
          res.push_back(ans);
          return;
      }
      for (int j=i; j<s.size(); ++j) {
          if (is_available(i,j)) {
              ans.push_back(s.substr(i,j-i+1));
              backtrack(s, j+1);
              ans.pop_back();
          }
      }
  }
#+END_SRC
** 例题
*** 例题[[https://leetcode-cn.com/problems/palindrome-partitioning/][131. 分割回文串]]
#+BEGIN_SRC cpp
  vector<vector<string>> partition(string s) {
      int n = s.size();
      vector<vector<int>> f(n, vector<int>(n, 1));
      for (int i=n-1; i>=0; --i) {
          for (int j=i+1; j<n; ++j) {
              f[i][j] = f[i+1][j-1]&&(s[i]==s[j]);
          }
      }
      vector<string> ans;
      vector<vector<string>> res;
      backtrack(s, 0, f, ans, res);
      return res;
  }

  void backtrack(string &s, int i, vector<vector<int>> &f, vector<string> &ans, vector<vector<string>> &res) {
      if(i==s.size()) {
          res.push_back(ans);
          return;
      }
      for (int j=i; j<s.size(); ++j) {
          if (f[i][j]) {
              ans.push_back(s.substr(i,j-i+1));
              backtrack(s, j+1, f, ans, res);
              ans.pop_back();
          }
      }
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/subsets/][78. 子集]]
**** 回溯法
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<vector<int>> res;
      vector<vector<int>> subsets(vector<int>& nums) {
          vector<int> temp;
          res.emplace_back(temp);
          helper(temp, nums);
          return res;
      }

      void helper(vector<int>& cur,const vector<int>& nums) {
          for (auto iter=nums.begin(); iter!=nums.end(); ++iter) {
              cur.emplace_back(*iter);
              res.emplace_back(cur);
              helper(cur, vector<int>(iter+1, nums.end()));
              cur.pop_back();
          }
      }
  };
#+END_SRC
**** 二进制
#+BEGIN_SRC cpp
  vector<vector<int>> subsets(vector<int>& nums) {
      int n = 1<<nums.size();
      vector<vector<int>> res;
      for (int i=0; i<n; ++i) {
          vector<int> temp;
          for (int j=0; j<nums.size(); ++j) {
              if (i>>j & 1) {
                  temp.emplace_back(nums[j]);
              }
          }
          res.emplace_back(temp);
      }
      return res;
  }
#+END_SRC
用二进制位来表示是否包含某一位数
*** 例题[[https://leetcode-cn.com/problems/subsets-ii/][90. 子集 II]]
**** 原理：对于当前选择的数x，若前面有与其相同的数y，且没有选择y，此时包含x的子集，必然会出现在包含y的所有子集中；也就是说，首先对数组排序，然后在迭代时，如果某一个数等于前数相等，并且前数没有入选，则可以跳过这个数的后续生成；
**** 回溯法
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<vector<int>> res;
      vector<vector<int>> subsetsWithDup(vector<int>& nums) {
          sort(nums.begin(), nums.end());
          vector<int> temp;
          res.emplace_back(temp);
          helper(temp, nums);
          return res;
      }

      void helper(vector<int>& cur,const vector<int>& nums) {
          for (auto iter=nums.begin(); iter!=nums.end(); ++iter) {
              if (iter!=nums.begin()&&*(iter-1)==*iter) continue;
              cur.emplace_back(*iter);
              res.emplace_back(cur);
              helper(cur, vector<int>(iter+1, nums.end()));
              cur.pop_back();
          }
      }
  };
#+END_SRC
**** 二进制
#+BEGIN_SRC cpp
  vector<vector<int>> subsetsWithDup(vector<int>& nums) {
      sort(nums.begin(), nums.end());
      int n = 1<<nums.size();
      vector<vector<int>> res;
      for (int i=0; i<n; ++i) {
          vector<int> temp;
          bool flag = true;
          for (int j=0; j<nums.size(); ++j) {
              if (i>>j&1) {
                  if (j>0&&nums[j]==nums[j-1]&&!(i>>(j-1)&1)) {
                      flag = false;
                      break;
                  }
                  temp.emplace_back(nums[j]);
              }
          }
          if (flag) res.emplace_back(temp);
      }
      return res;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/permutations/][46. 全排列]]
**** 原理：对唯一的一个数组进行排列来枚举所有可能；用一个变量来记录当前已经排列的位数，将后面未参与排列的每个可能的数字交换至待排序的下一位，递归，然后回溯后再换回来；例如：[1,2,3|4,5,6,7]交换后是[1,2,3|6,5,4,7]
**** 代码
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<vector<int>> res;
      vector<vector<int>> permute(vector<int>& nums) {
          backtrace(nums, 0);
          return res;
      }
      void backtrace(vector<int> &nums, int i) {
          if (i==nums.size()) {
              res.emplace_back(nums);
          }
          for (int j=i; j<nums.size(); ++j) {
              swap(nums[i], nums[j]);
              backtrace(nums, i+1);
              swap(nums[i], nums[j]);
          }
      }
  };
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/permutations-ii/][47. 全排列 II]]
**** 原理：可对数组先进行排序，让重复元素都相邻，并且对于每次选择，只让重复元素中的第一个参与选择；由于对元素的排列顺序右要求，所以无法再使用上题的交换法，而采用一个额外的数组来记录元素是否被选择过；对于每次选择，如果某个元素等于前一个元素，且前一个元素未被选择（即前者与其属于同一个选择回合），则跳过该元素的选择，即只让前一个元素参与选择
**** 代码
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<vector<int>> res;
      vector<int> v;
      vector<vector<int>> permuteUnique(vector<int>& nums) {
          v.resize(nums.size());
          sort(nums.begin(), nums.end());
          vector<int> temp;
          backtrace(nums, temp, 0);
          return res;
      }

      void backtrace(vector<int> &nums, vector<int> &temp, int i) {
          if (i==nums.size()) {
              res.emplace_back(temp);
          }
          for (int j=0; j<nums.size(); ++j) {
              if (v[j]!=0||(j>0&&nums[j]==nums[j-1]&&v[j-1]==0)) continue;
              temp.emplace_back(nums[j]);
              v[j] = 1;
              backtrace(nums, temp, i+1);
              v[j] = 0;
              temp.pop_back();
          }
      }
  };
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/combination-sum/][39. 组合总和]]
**** 原理：搜索回溯每次可选择任意加入不会超出target数字，当target满足时，将组合添加进结果数组；为了保证不出现类似[2,2,3]和[3,2,2]的重复，先对原数组进行排序，然后限制每次可选择的数大于等于上次选择的数
**** 代码
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<vector<int>> res;
      vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
          vector<int> ans;
          sort(candidates.begin(), candidates.end());
          backtrace(ans, candidates, target, 0);
          return res;
      }

      void backtrace(vector<int>& ans, vector<int>& candidates, int target, int i) {
          if (target==0) {
              res.emplace_back(ans);
          }
          for (int j=i; j<candidates.size(); ++j) {
              if (candidates[j]<=target) {
                  ans.emplace_back(candidates[j]);
                  backtrace(ans, candidates, target-candidates[j], j);
                  ans.pop_back();
              }
          }
      }
  };
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/][17. 电话号码的字母组合]]
*** 例题[[https://leetcode-cn.com/problems/restore-ip-addresses/][93. 复原 IP 地址]]
**** 注意：
***** atoi()接收的参数是C风格char数组，string要调用c_str()才行
***** 当超过255时可以提前结束循环
*** 例题[[https://leetcode-cn.com/problems/generate-parentheses/][22. 括号生成]]
**** 代码1（回溯）
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<string> res;
      vector<string> generateParenthesis(int n) {
          string s;
          backtrace(n, n, s);
          return res;
      }
      void backtrace(int m, int n, string& s) {
          if(m==0&&n==0) {
              res.emplace_back(s);
              return;
          }

          if (m>0) {
              s += '(';
              backtrace(m-1, n, s);
              s = s.substr(0, s.size()-1);
          }
          if (n>0&&n>m) {
              s += ')';
              backtrace(m, n-1, s);
              s = s.substr(0, s.size()-1);
          }
      }
  };
#+END_SRC
**** 代码2（按括号长度递归）
#+BEGIN_SRC cpp
  class Solution {
  public:
      vector<vector<string>> map;
      vector<string> generateParenthesis(int n) {
          map.resize(n+1);
          generate(n);
          return map[n];
      }
      void generate(int n) {
          if (map[n].size()!=0) return;
          if (n==0) map[n].emplace_back("");
          for (int i=1; i<2*n; i=i+2) {
              generate((i-1)/2);
              generate(n-(i+1)/2);
              for (string &a : map[(i-1)/2]) {
                  for (string &b : map[n-(i+1)/2]) {
                      map[n].emplace_back('('+a+')'+b);
                  }
              }
          }
      }
  };
#+END_SRC
***** 对于n对括号的生成，可以遍历与第一个"("配对的")"的位置，将串划分为"(a)b"，对于a和b去递归计算其可能的括号组合
***** 对于已经计算过的n对括号组合，可以将其记录下来方便重复调用
*** 例题[[https://leetcode-cn.com/problems/word-search/][79. 单词搜索]]
#+BEGIN_SRC cpp
  class Solution {
  public:
      bool exist(vector<vector<char>>& board, string word) {
          int h = 0;
          for (const vector<char>& row : board)
              for (const char& c : row) {
                  if (c == word[0])
                      h += 1;
                  else if (c == word.back())
                      h -= 1;
              }
          //剪枝，用少的那个。估计是可以剪掉那个刚好很多重复头元素的
          if (h > 0) reverse(word.begin(), word.end());
          int m = board.size();
          int n = board[0].size();
          for (int i=0; i<m; ++i) {
              for (int j=0; j<n; ++j) {
                  if (board[i][j]==word[0]) {
                      board[i][j] = '0';
                      if (backtrace(board, word, i, j, 1)) return true;
                      board[i][j] = word[0];
                  }
              }
          }
          return false;
      }
      bool backtrace(vector<vector<char>>& board, string& word, int i, int j, int x) {
          if (x==word.size()) {
              return true;
          }
          int m = board.size();
          int n = board[0].size();
          if (i>0&&board[i-1][j]==word[x]) {
              board[i-1][j] = '0';
              if (backtrace(board, word, i-1, j, x+1)) return true;
              board[i-1][j] = word[x];
          }
          if (j<n-1&&board[i][j+1]==word[x]) {
              board[i][j+1] = '0';
              if (backtrace(board, word, i, j+1, x+1)) return true;
              board[i][j+1] = word[x];
          }
          if (i<m-1&&board[i+1][j]==word[x]) {
              board[i+1][j] = '0';
              if (backtrace(board, word, i+1, j, x+1)) return true;
              board[i+1][j] = word[x];
          }
          if (j>0&&board[i][j-1]==word[x]) {
              board[i][j-1] = '0';
              if (backtrace(board, word, i, j-1, x+1)) return true;
              board[i][j-1] = word[x];
          }
          return false;
      }
  };
#+END_SRC
**** 使用回溯法
**** 但是可以针对大量的重复头元素进行裁剪；如果重复的头元素过多，可以进行将word字符串倒转，从最后一个元素开始查找
* 分治法
** 例题
*** 例题[[https://leetcode-cn.com/problems/unique-binary-search-trees-ii/][95. 不同的二叉搜索树 II]]
**** 代码
#+BEGIN_SRC cpp
  vector<TreeNode*> generateTrees(int n) {
      return generateTrees(1,n);
  }

  vector<TreeNode*> generateTrees(int start, int end) {
      if (start>end) {
          return {nullptr};
      }
      vector<TreeNode*> res;
      for (int i=start; i<=end; ++i) {
          vector<TreeNode*> left = generateTrees(start, i-1);
          vector<TreeNode*> right = generateTrees(i+1, end);

          for (auto iterl=left.begin(); iterl!=left.end(); ++iterl) {
              for (auto iterr=right.begin(); iterr!=right.end(); ++iterr) {
                  TreeNode* root = new TreeNode(i);
                  root->left = *iterl;
                  root->right = *iterr;
                  res.emplace_back(root);
              }
          }
      }
      return res;
  }
#+END_SRC
* 滑动窗口
** 例题
*** 例题[[https://leetcode-cn.com/problems/minimum-window-substring/][76. 最小覆盖子串]]
**** 代码1
#+BEGIN_SRC cpp
  class Solution {
  public:
      int maps[128] = {0};
      int mapt[128] = {0};
      string minWindow(string s, string t) {
          for (int i=0; i<t.size(); ++i) {
              mapt[t[i]]++;
          }
          int i = -1,j = 0;
          int min_len = INT_MAX,min_i = -1,min_j = -1;
          while (i<(int)(s.size()-1)) {
              maps[s[++i]]++;
              while (check()) {
                  if (i-j+1<min_len) {
                      min_len = i-j+1;
                      min_i = i;
                      min_j = j;
                  }
                  maps[s[j++]]--;
              }
          }
          return min_i>=0?s.substr(min_j,min_i-min_j+1):"";
      }

      bool check() {
          for (int i=0;i<256;++i) {
              if (mapt[i]>0&&maps[i]<mapt[i]) return false; 
          }
          return true;
      }
  };
#+END_SRC
**** 代码2
#+BEGIN_SRC cpp
  string minWindow(string s, string t) {
      int ns = s.size();
      int nt = t.size();
      int map[128] = {0};
      for (int i=0; i<nt; ++i) {
          map[t[i]]++;
      }

      int i = -1,j = 0;
      int min_len = INT_MAX,min_i = -1,min_j = -1;
      while (i<ns-1) {
          if (map[s[++i]]>0) {
              nt--;
          }
          map[s[i]]--;
          if (nt==0) {
              while (map[s[j]]<0) {
                  map[s[j++]]++;
              }
              if (i-j+1<min_len) {
                  min_len = i-j+1;
                  min_i = i;
                  min_j = j;
              }
              map[s[j++]]++;
              nt++;
          }
      }
      return min_i>=0?s.substr(min_j,min_i-min_j+1):"";
  }
#+END_SRC
***** 可利用数组map来判断j是否缩小到最小窗口：因为用字符串t先预处理过map，因此当j缩小时，只有t中的字符，才有可能大于0，并且是在缩小到最小窗口时
*** 例题[[https://leetcode-cn.com/problems/permutation-in-string/][567. 字符串的排列]]
**** 代码1（滑动窗口）
#+BEGIN_SRC cpp
  bool checkInclusion(string s1, string s2) {
      int n1 = s1.size();
      int n2 = s2.size();
      if (n1>n2) return false;
      vector<int> map(26);
      for (int i=0; i<n1; ++i) {
          map[s2[i]-'a']++;
          map[s1[i]-'a']--;
      }
      int diff = 0;
      for (int i=0; i<26; ++i) {
          if (map[i]!=0) {
              diff++;
          }
      }
      if(diff==0) return true;

      int j = n1;
      while (j<n2) {
          if (s2[j]!=s2[j-n1]) {
              if (map[s2[j]-'a']==0) diff++;
              else if(map[s2[j]-'a']==-1) diff--;
              if (map[s2[j-n1]-'a']==0) diff++;
              else if(map[s2[j-n1]-'a']==1) diff--;
              map[s2[j]-'a']++;
              map[s2[j-n1]-'a']--;
          }
          if(diff==0) return true;
          j++;
      }
      return false;
  }
#+END_SRC
**** 代码2（双指针）
#+BEGIN_SRC cpp
  bool checkInclusion(string s1, string s2) {
      int n1 = s1.size();
      int n2 = s2.size();
      vector<int> map(26);
      for (int i=0; i<n1; ++i) {
          map[s1[i]-'a']--;
      }

      int i = 0, j = 0;
      while (i<n2) {
          map[s2[i]-'a']++;
          while (map[s2[i]-'a']>0) {
              map[s2[j++]-'a']--;
          }
          if (i-j+1==n1) return true;
          i++;
      }
      return false;
  }
#+END_SRC
*** 例题[[https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/][438. 找到字符串中所有字母异位词（同上）]]
*** 例题[[https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/][3. 无重复字符的最长子串]]
**** 代码
#+BEGIN_SRC cpp
  int lengthOfLongestSubstring(string s) {
      int n = s.size();
      int map[128];
      for (int i=0;i<128;++i) map[i] = -1;
      int max_length = 0;
      int i=0;
      int j=0;
      while (i<n) {
          if (j<=map[s[i]]) { // 注意收缩的判断条件
              max_length = max(max_length,i-j);
              j = map[s[i]]+1;
          }
          map[s[i]] = i;
          i++;
      }
      max_length = max(max_length,i-j);
      return max_length;
  }
#+END_SRC
* 栈
** 例题
*** 例题[[https://leetcode-cn.com/problems/min-stack/][155. 最小栈]]
**** 代码1（辅助栈）
#+BEGIN_SRC cpp
  class MinStack {
  public:
      MinStack() {
          s2.push(INT_MAX); // 记得考虑第一个数的情况，加上个最大的值
      }
    
      void push(int val) {
          s1.push(val);
          s2.push(::min(s2.top(),val));
      }
    
      void pop() {
          s1.pop();
          s2.pop();
      }
    
      int top() {
          return s1.top();
      }
    
      int getMin() {
          return s2.top();
      }
    
  private:
      stack<int> s1;
      stack<int> s2;
  };
#+END_SRC
***** 开辟一个辅助栈用来存储当前状态下的最小值（注意：记得考虑压入第一个元素时的情况！）
**** 代码2（空间复杂度O(1)）
#+BEGIN_SRC cpp
  class MinStack {
  public:
      /** initialize your data structure here. */
      MinStack() {
          _min = INT_MAX;
      }
    
      void push(int x) {
          s.push(_min-x);
          if (_min>x) {
              _min = x;
          }
      }
    
      void pop() {
          if (s.top()>0) {
              _min = s.top()+_min;
          }
          s.pop();
      }
    
      int top() {
          if (s.top()>0) {
              return _min;
          }
          else {
              return _min-s.top();
          }
      }
    
      int getMin() {
          return _min;
      }
      stack<long long> s;
      long long _min;
  };
#+END_SRC
***** 利用一个变量_min来记录最小值，而栈中记录的是和上一次最小值的差值；因此当调用pop()时，需要根据栈顶的值和_min来还原前一次_min值；当调用top()时，若s.top()>0则返回_min，反之则返回_min-s.top()
*** 例题[[https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/][剑指 Offer 03. 数组中重复的数字]]
**** 代码1（哈希表）
#+BEGIN_SRC cpp
  int findRepeatNumber(vector<int>& nums) {
      int n = nums.size();
      vector<int> map(n);
      for (int i=0;i<n;++i) {
          if (map[nums[i]]==0) map[nums[i]]++;
          else return nums[i];
      }
      return -1;
  }
 #+END_SRC
**** 代码2（重排数组，空间复杂度O(1)）
#+BEGIN_SRC cpp
  int findRepeatNumber(vector<int>& nums) {
      for (int i=0;i<nums.size();++i) {
          if (nums[i]!=i) {
              if (nums[i]==nums[nums[i]]) {
                  return nums[i];
              }
              else {
                  int temp = nums[nums[i]];
                  nums[nums[i]] = nums[i];
                  nums[i] = temp;
                  --i;
              }
          }
      }
      return -1;
  }
#+END_SRC
***** 重排数组，将元素交换到下标等于其数值的位置，自然会遇上重复元素
**** 代码3（原地标注，空间复杂度O(1)）
#+BEGIN_SRC cpp
  int findRepeatNumber(vector<int>& nums) {
      int n = nums.size();
      for(int i = 0; i < n; i++){
          int k = nums[i];
          if(k < 0) k += n;
          if(nums[k] < 0) return k;
          nums[k] -= n;
      }
      return -1;
  }
#+END_SRC
***** 当所有元素都大于0时，可以利用元素减去最大值来进行标注，从而省掉一个哈希表
*** 例题[[https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/][剑指 Offer 09. 用两个栈实现队列]]
* 字符串
** 例题
*** 例题[[https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/][剑指 Offer 05. 替换空格]]
#+BEGIN_SRC cpp
  string replaceSpace(string s) {
      int n = s.size();
      int count = 0;
      for (auto &a : s) {
          if (a==' ')
              count++;
      }
      s.resize(n+count*2);
      for (int i=n-1,j=s.size()-1;i>=0,j>=0;--i) {
          if (s[i]==' ') {
              s[j--] = '0';
              s[j--] = '2';
              s[j--] = '%';
          }
          else {
              s[j--] = s[i];
          }
      }
      return s;
  }
#+END_SRC
**** 对于这类修改后会变大的数组，可以采用倒序复制
*** 例题[[https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/][剑指 Offer 58 - II. 左旋转字符串]]
* 二维数组中的查找
** 例题[[https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/][剑指 Offer 04. 二维数组中的查找]]
#+BEGIN_SRC cpp
  bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
      if(matrix.size()==0||matrix[0].size()==0) return false;
      int m = matrix.size();
      int n = matrix[0].size();
      int x = 0;
      int y = n-1;
      while (x<m&&y>=0) {
          if (matrix[x][y]>target)
              --y;
          else if (matrix[x][y]<target)
              ++x;
          else
              return true;
      }
      return false;
  }
#+END_SRC
*** 从二维数组的右上角开始查；如果当前元素等于目标值，则返回 true；如果当前元素大于目标值，则移到左边一列；如果当前元素小于目标值，则移到下边一行；可以证明这种方法不会错过目标值；如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值；如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值
*** 可以从右上角或左下角开始查找，但不能从左上角和右下角开始查找
* 优先队列
** 例题[[https://leetcode-cn.com/problems/merge-k-sorted-lists/][23. 合并K个升序链表]]
*** 代码1（优先队列，时间复杂度O(kn*logk)）
#+BEGIN_SRC cpp
  class Solution {
  public:
      // 优先队列
      struct Status {
          int val;
          ListNode* node;
          Status(int v, ListNode* n) : val(v),node(n) {}
          bool operator<(const Status &rhs) const {
              return val>rhs.val;
          }
      };
      ListNode* mergeKLists(vector<ListNode*>& lists) {
          ListNode* dummy = new ListNode;
          ListNode* tail = dummy;
          priority_queue<Status> qu;
          for (ListNode* node : lists) {
              if (node) qu.push(Status(node->val,node));
          }
          while (!qu.empty()) {
              ListNode* node = qu.top().node;
              qu.pop();
              tail->next = node;
              tail = tail->next;
              if (node->next) qu.push(Status(node->next->val, node->next));
          }
          return dummy->next;;
      }
  };
#+END_SRC
**** 利用priority_queue来获取当前最小的头元素（priority_queue内部采用小顶堆来实现，插入的时间复杂度为O(logn)）
*** 代码2（分治法，时间复杂度O(kn*logk)）
#+BEGIN_SRC cpp
  class Solution {
  public:
      ListNode* mergeKLists(vector<ListNode*>& lists) {
          int n = lists.size();
          if (n==0) return nullptr;
          for (int i=1; i<n; i<<=1) {
              int j = 0;
              while (j+i<n) {
                  lists[j] = merge(lists[j], lists[j+i]);
                  j = j+i*2;
              }
          }
          return lists[0];
      }
      ListNode* merge(ListNode* a, ListNode*b) {
          ListNode* dummy = new ListNode;
          ListNode* cur = dummy;
          while (a&&b) {
              if (a->val<b->val) {
                  cur->next = a;
                  a = a->next;
              }
              else {
                  cur->next = b;
                  b = b->next;
              }
              cur = cur->next;
          }
          if (a) {
              cur->next = a;
          }
          if (b) {
              cur->next = b;
          }
          return dummy->next;
      }
  };
#+END_SRC
* 数学
** 例题[[https://leetcode-cn.com/problems/rotate-image/][48. 旋转图像]]
*** 代码1（临时变量）
#+BEGIN_SRC cpp
  void rotate(vector<vector<int>>& matrix) {
      int n = matrix.size();
      for (int k=0; k<n/2; ++k) {
          for (int i=k; i<n-k-1; ++i) {
              int x = k, y = i;
              for (int j=1; j<4; ++j) {
                  int temp = matrix[k][i];
                  int temp_x = y;
                  int temp_y = n-x-1; 
                  x = temp_x;
                  y = temp_y;
                  matrix[k][i] = matrix[x][y];
                  matrix[x][y] = temp;
              }
          }
      }
  }
#+END_SRC
*** 代码2（用翻转代替旋转）
#+BEGIN_SRC cpp
  void rotate(vector<vector<int>>& matrix) {
      int n = matrix.size();
      for (int i=0; i<n/2; ++i) {
          for (int j=0; j<n; ++j) {
              swap(matrix[i][j], matrix[n-i-1][j]);
          }
      }
      for (int i=0; i<n-1; ++i) {
          for (int j=i+1; j<n; ++j) {
              swap(matrix[i][j], matrix[j][i]);
          }
      }
  }
#+END_SRC
**** 顺时针旋转90度本质上想当于先上下翻转，然后再沿对角线翻转
** 例题[[https://leetcode-cn.com/problems/majority-element/][169. 多数元素]]
*** 代码1（Boyer-Moore投票算法）
#+BEGIN_SRC cpp
  int majorityElement(vector<int>& nums) {
      int count = 0;
      int res;
      for (int n : nums) {
          if (count==0) {
              res = n;
          }
          if (res==n) {
              ++count;
          }
          else {
              --count;
          }
      }
      return res;
  }
#+END_SRC
**** 设定一个计数变量初始为0
**** 遍历数组，若计数变量为0则令候选众数等于当前数；若候选众数等于当前数则计数变量加1，若候选众数不等于当前数则计数变量减1
**** 遍历完成时，候选众数为真正的众数
*** 代码2（排序）
#+BEGIN_SRC cpp
  int majorityElement(vector<int>& nums) {
      sort(nums.begin(), nums.end());
      return nums[nums.size()/2];
  }
#+END_SRC
*** 代码3（哈希表）
#+BEGIN_SRC cpp
  int majorityElement(vector<int>& nums) {
      unordered_map<int,int> map;
      int count = 0;
      int res = 0;
      for (int n : nums) {
          ++map[n];
          if (count<map[n]) {
              count = map[n];
              res = n;
          }
      }
      return res;
  }
#+END_SRC
*** 代码4（随机法）
#+BEGIN_SRC cpp
  int majorityElement(vector<int>& nums) {
      while (1) {
          int res = nums[rand()%nums.size()];
          int count = 0;
          for (int n : nums) {
              if (n==res) ++count;
          }
          if (count>nums.size()/2) {
              return res;
          }
      }
      return -1;
  }
#+END_SRC
*** 代码5（分治）
#+BEGIN_SRC cpp
  int majorityElement(vector<int>& nums) {
      return getMajorityElement(nums, 0, nums.size()-1);
  }
  int getMajorityElement(vector<int>& nums, int i, int j) {
      if (i==j) {
          return nums[i];
      }
      int mid = (i+j)/2;
      int leftM = getMajorityElement(nums, i, mid);
      int rightM = getMajorityElement(nums, mid+1, j);
      int leftC = 0;
      int rightC = 0;
      for (int k=i; k<=j; ++k) {
          if (nums[k]==leftM) ++leftC;
          else if (nums[k]==rightM) ++rightC;
      }
      return leftC>rightC?leftM:rightM;
  }
#+END_SRC
* LRU
** 例题[[https://leetcode-cn.com/problems/lru-cache/][146. LRU 缓存]]
#+BEGIN_SRC cpp
  class LRUCache {
  public:
      struct DListNode {
          int key, value;
          DListNode* pre;
          DListNode* next;
          DListNode() : key(0), value(0), pre(nullptr), next(nullptr) {}
          DListNode(int _key, int _value) : key(_key), value(_value), pre(nullptr), next(nullptr) {}
      };

      LRUCache(int capacity) {
          _max = capacity;
          _head = new DListNode;
          _tail = new DListNode;
          _head->next = _tail;
          _tail->pre = _head;
      }
    
      int get(int key) {
          auto iter = _map.find(key);
          if (iter!=_map.end()) { // 存在则移动到链表头部并返回值
              moveToHead(iter->second);
              return iter->second->value;
          }
          else { // 不存在
              return -1;
          }
      }
    
      void put(int key, int value) {
          auto iter = _map.find(key);
          if (iter!=_map.end()) { //存在则移动到链表头部并改变值
              moveToHead(iter->second);
              iter->second->value = value;
          }
          else { // 不存在
              if (_map.size()==_max) { // 若达到上限则删除链表末尾元素
                  DListNode* node = removeTail();
                  _map.erase(node->key);
                  delete node;
              }
              _map[key] = new DListNode(key, value);
              addToHead(_map[key]);
          }
      }
  private:
      void addToHead(DListNode* node) {
          node->pre = _head;
          node->next = _head->next;
          _head->next = node;
          node->next->pre = node;
      }

      void remove(DListNode* node) {
          node->pre->next = node->next;
          node->next->pre = node->pre;
      }
    
      void moveToHead(DListNode* node) {
          remove(node);
          addToHead(node);
      }

      DListNode* removeTail() {
          DListNode* node = _tail->pre;
          remove(node);
          return node;
      }
    
      int _max;
      DListNode* _head;
      DListNode* _tail;
      unordered_map<int,DListNode*> _map;
  };
#+END_SRC
*** 用一个双向链表和一个哈希表实现；双向链表用来记录最近使用顺序，哈希表用来加速查找
* 字典树
** 例题[[https://leetcode.cn/problems/implement-trie-prefix-tree/][208. 实现 Trie (前缀树)]]
*** 注意点开题解看其查找方法（非递归）
