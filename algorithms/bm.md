## BM算法 ##
#### 1. BM算法核心规则
在暴力匹配过程中，当发生失配时，需要将串指针回退，因此我们在BM算法中，采用倒着匹配的方式，如果发生失配，将模式串指针移到串末尾，并根据坏字符和好后缀数组尽可能远地向后移动主串指针

代码实现如下：
```cpp
int indexBM(char *s, int sLength, char *t, int tLength, int pos, int *b, int *g) {
    int i = tLength - 1;
    int j = pos + i;
    while (i >= 0 && j < sLength) {
        if (t[i] == s[j]) { // 当主串和模式串对应位字符相等时，i和j都右移一位
            i--;
            j--;
        } else { // 否则，i移动到模式串末尾，j根据坏字符和好后缀数组尽可能远地向后移动
            j += g[i] > b[s[j]] ? g[i] : b[s[j]];
            i = tLength - 1;
        }
    }
    if (i < 0)
        return j + 1;
    else
        return -1;
}
```
#### 2. 基本思路
大家来头脑风暴下：如何加快字符串搜索？举个很简单的例子，如下图所示，navie表示一般做法，逐个进行比对，从右向左，最后一个字符c与text中的d不匹配，pattern右移一位。但大家看一下这个d有什么特征？pattern中没有d，因此你不管右移1、2、3、4位肯定还是不匹配，何必花这个功夫呢？直接右移5（strlen(pattern)）位再进行比对不是更好吗？好，就这样做，右移5位后，text中的b与pattern中的c比较，发现还是不同，这时咋办？b在pattern中有所以不能一下右移5位了，难道直接右移一位吗？No，可以直接将pattern中的b右移到text中b的位置进行比对，但是pattern中有两个b，右移哪个b呢？保险的办法是用最右边的b与text进行比对，为啥？下图说的很清楚了，用最左边的b太激进了，容易漏掉真正的匹配，图中用最右边的b后发现正好所有的都匹配成功了，如果用最左边的不就错过了这个匹配项吗？这个启发式搜索就是BM算法做的。

|           | 0 | 1 | 2 | 3 | 4     | 5     | 6 | 7     | 8 | 9     | 10 | 11 | 12 | 13 |                          |
|-----------|---|---|---|---|-------|-------|---|-------|---|-------|----|----|----|----|--------------------------|
| text      | a | b | b | a | **d** | c     | a | b     | a | **b** | a  | c  | a  | b  |                          |
| pattern   | b | a | b | a | c     |       |   |       |   |       |    |    |    |    |                          |
| native    |   | b | a | b | a     | c     |   |       |   |       |    |    |    |    | 太保守，进行不必要的比较 |
| **BM**    |   |   |   |   |       | **b** | a | **b** | a | c     |    |    |    |    |                          |
| **BM(✖)** |   |   |   |   |       |       |   |       |   | b     | a  | b  | a  | c  | 太激进，可能漏掉         |
| **BM(✔)** |   |   |   |   |       |       |   | b     | a | b     | a  | c  |    |    |                          |

 But, 如果遇到下面这样的情况，开始pattern中的c和text中的b不匹配，Ok，按上面的规则将pattern右移直至最右边的b与text的b对齐进行比对。再将pattern中的c与text中的c进行比对，匹配继续往左比对，直到位置3处pattern中的a与text中的b不匹配了，按上面讲的启发式规则应该将pattern中最右边的b与text的b对齐，可这时发现啥了？pattern走了回头路，干吗？当然不干，才不要那么傻，针对这种情况，只需要将pattern简单的右移一步即可，坚持不走回头路！

|           | 0 | 1 | 2 | 3     | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 |                        |
|-----------|---|---|---|-------|---|---|---|---|---|---|----|----|----|----|------------------------|
| text      | a | b | c | **b** | b | a | c | b | a | b | a  | c  | a  | b  |                        |
| pattern   | b | a | b | a     | c |   |   |   |   |   |    |    |    |    |                        |
| **BM**    |   |   | b | **a** | b | a | c |   |   |   |    |    |    |    | 启发式搜索             |
| **BM(✖)** |   | b | a | **b** | a | c |   |   |   |   |    |    |    |    | 这是在走回头路啊       |
| **BM(✔)** |   |   |   | b     | a | b | a | c |   |   |    |    |    |    | 该情况只需简单右移一步 |

好了，这就是所谓的“坏字符算法”，简单吧，通俗易懂吧，上面用粗体字标注出来的b就是“坏字符”，即不匹配的字符，坏字符是针对text的。

BM难道就这么简单？就一个启发式规则就搞定了？当然不是了，大家再次头脑风暴一下，有没有其他加快字符串搜索的方法呢？比如下面的例子

|           | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8     | 9     | 10 | 11 | 12 | 13 |                        |
|-----------|---|---|---|---|---|---|---|---|-------|-------|----|----|----|----|------------------------|
| text      | a | b | c | a | a | c | b | a | a     | b     | a  | c  | a  | b  |                        |
| pattern   | b | c | a | b | a | b |   |   |       |       |    |    |    |    |                        |
| **BM**    |   |   |   |   | b | c | a | b | **a** | **b** |    |    |    |    | 利用了坏字符算法       |
| **BM(✖)** |   |   |   |   |   | b | c | a | b     | a     | b  |    |    |    | 没走回头路，保守移一位 |
| **BM(✔)** |   |   |   |   |   |   | b | c | **a** | **b** | a  | b  |    |    | 完全可以一次性移两位   |

一开始利用了坏字符算法一下移了4位，不错，接下来遇到了回头路，没办法只能保守移一位，但真的就只能移一位吗？No，因为pattern中前面其他位置也有刚刚匹配成功的后缀ab，那么将pattern前面的ab右移到text刚匹配成功的ab对齐继续往前匹配不是更好吗？这样就可以一次性右移两位了，很好的有一个启发式搜索规则啊。有人可能想：要是前面没已经匹配成功的后缀咋办？是不是就无效了？不完全是，这要看情况了，比如下面这个例子。

|           | 0 | 1 | 2 | 3 | 4 | 5     | 6     | 7     | 8     | 9 | 10 | 11 | 12 | 13 |                        |
|-----------|---|---|---|---|---|-------|-------|-------|-------|---|----|----|----|----|------------------------|
| text      | a | b | c | a | a | c     | b     | a     | b     | b | a  | c  | a  | b  |                        |
| pattern   | a | b | c | b | a | b     |       |       |       |   |    |    |    |    |                        |
| **BM**    |   |   |   | a | b | **c** | **b** | **a** | **b** |   |    |    |    |    | 利用了坏字符算法       |
| **BM(✖)** |   |   |   |   | a | b     | c     | b     | a     | b |    |    |    |    | 没走回头路，保守移一位 |
| **BM(✔)** |   |   |   |   |   |       |       | **a** | **b** | c | a  | b  |    |    | 完全可以一次性移四位   |

cbab这个后缀已经成功匹配，然后b没成功，而pattern前面也没发现cbab这样的串，这样就直接保守移一位？No，前面有ab啊，这是cbab后缀的一部分，也可以好好利用，直接将pattern前面的ab右移到text已经匹配成功的ab位置处继续往前匹配，这样一下子就右移了四位，很好。当然，如果前面完全没已经匹配成功的后缀或部分后缀，比如最前面的babac，那就真的不能利用了。

好了，这就是所谓的“好后缀算法”，简单吧，通俗易懂吧，上面用粗体字标注出来的ab（前面例子）和cbab（上面例子）就是“好后缀”，好后缀是针对pattern的。

下面，最后再举个例子说明啥是坏字符，啥是好后缀。

主串  :  mahtavaa[t]**aloma**isema omalomailuun

模式串: maisemao[m]**aloma**

坏字符：主串中的“t”为坏字符。

好后缀：模式串中的aloma为“好后缀”。

BM就这么简单？是的，容易理解但并不是每个人都能想到的两个启发式搜索规则就造就了BM这样一个优秀的算法。那么又有个问题？这两个算法怎么运用，一下坏字符的，一下好后缀的，什么时候该用坏字符？什么时候该用好后缀呢？很好的问题，这就要看哪个右移的位数多了，比如上面的例子，一开始如果用好后缀的话只能移一位而用坏字符就能右移三位，此时当然选择坏字符算法了。接下来如果继续用坏字符则只能右移一位而用好后缀就能一下右移四位，这时候你说用啥呢？So，这两个算法是“并行”的，哪个大用哪个。
#### 3. 坏字符匹配
我们构建一个坏字符表，描述了每个可能的坏字符在模式串中最后一个出现位置到串末尾的距离（保守移动，这是最少需要移动的距离），如果坏字符没有出现在模式串中，则坏字符表中对应位置则填入模式串长度（即模式串移动到主串中坏字符位置的下一位）

代码实现如下：
```cpp
void buildBads(char *t, int tLength, int bads[256]) {
	// 前一个循环用来处理第一种规则，因为遇见不匹配时，直接移动模式串的长度
    for (int i = 0; i < 256; ++i)
        bads[i] = tLength;
	// 后一个循环处理第二种规则，需要注意的是，因为要保证最靠右原则，所以要从头开始循环，从而使得当遇见相同的字符，后者可以将前者进行覆盖
    for (int i = 0; i < tLength; ++i)
        bads[t[i]] = tLength - 1 - i;
}
```
思考：坏字符匹配规则中是不是有可能出现模式串不向后移动反而向前的情况（回头路）？
#### 4. 好后缀规则
如果程序匹配了一个好后缀，那么有以下三种可能：  
(1) 模式串中有子串和好后缀完全匹配，则将最靠右的那个子串移动到好后缀的位置继续进行匹配  
(2) 如果不存在和好后缀完全匹配的子串，则在好后缀中找到具有如下特征的最长子串,使得$'{p_{m-s}\dots p_m}'='{p_0\dots p_s}'$  
(3) 如果完全不存在和好后缀匹配的子串，则右移整个模式串

代码实现如下：
```cpp
void buildGoods(char *t, int tLength, int *goods, int *suff) {
	// 先全部赋值为tLength，包含Case3
    for (int i = 0; i < tLength; ++i) {
        goods[i] = 2 * tLength - 1 - i;
    }
	// Case2
    int j = 0;
    for (int i = tLength - 1; i >= 0; --i) {
        if (suff[i] == i + 1) {
            for (; j < tLength - 1 - i; ++j) {
                if (goods[j] == 2 * tLength - 1 - j)
                    goods[j] = 2 * tLength - 2 - i - j;
            }
        }
    }
	// Case1
    for (int i = 0; i < tLength - 1; ++i) {
        goods[tLength - 1 - suff[i]] = tLength - 1 - i + suff[i];
    }
}
```
##### 定义suffix数组：
`suffix[i]`为模式串中以i位置为后缀的子串与以最后一个字符为后缀的子串的最长公共长度；令m为模式串长度
$$ 
suffix[i]=\left\{
\begin{aligned}
& m\quad当i=m时 \\
& Max\{k|0<=k<=i+1且'{p_{i-k+1}\dots p_{i}}'='{p_{m-1-k+1}\dots p_{m-1}}'\}\quad其他情况
\end{aligned}
\right.
$$

代码实现如下：
```cpp
void suffixes(char *t, int tLength, int *suff) {
    suff[tLength - 1] = tLength;
    for (int i = tLength - 2; i >= 0; --i) {
        int j = i;
        while (j >= 0) {
            if (t[j] != t[tLength - 1 - i + j])
                break;
            j--;
        }
        suff[i] = i - j;
    }
}
```
##### suffix数组的改进：
i是当前正准备计算`suff[]`值的那个位置；f是上一个成功进行匹配的起始位置（不是每个位置都能进行成功匹配的，  实际上能够进行成功匹配的位置并不多）；g是上一次进行成功匹配的失配位置；如果i在g和f之间，那么一定有`P[i]=P[m-1-f+i]`；并且如果`suff[m-1-f+i] < i-g`, 则`suff[i] = suff[m-1-f+i]`，这不就利用了前面的`suff[]`了吗

PS：这里有些人可能觉得应该是`suff[m-1-f+i] <= i - g`，因为若`suff[m-1-f+i] = i - g`，还是没超过`suff[f]`的范围，依然可以利用前面的`suff[]`，但这是错误的，比如一个极端的例子：

| i       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---------|---|---|---|---|---|---|---|---|---|---|
| pattern | a | a | a | a | a | b | a | a | a | a |

`suff[4] = 4`，这里`f=4`，`g=0`，当`i=3`时，这时`suff[m-1=f+i]=suff[8]=3`，而`suff[3]=4`，两者不相等，因为上一次的失配位置g可能会在这次得到匹配

代码实现如下：
```cpp
void suffixes_new(char *t, int tLength, int *suff) {
    suff[tLength - 1] = tLength;
    int f = tLength - 1, g = 0;
    for (int i = tLength - 2; i >= 0; --i) {
	if (i != tLength - 2 && i > g && suff[i + tLength - 1 - f] < i - g) { // i>g且suff[i+tLength-1-f]<i-g(但不包括i=tLength-2的情形)
	    suff[i] = suff[i + tLength - 1 - f];
	} else {
	    if (i == tLength - 2 || i < g) { // i<g或i=tLength-2,否则i>g但suff[i+tLength-1-f]<i-g
		g = i;
	    }
	    f = i;
	    while (g >= 0) {
		if (t[g] != t[tLength - 1 - f + g])
		    break;
		g--;
	    }
            suff[i] = f - g;
        }
    }
}
```
#### 5.复杂度分析
* 时间复杂度：$O(n)$，其中$n$是模式串的长度
* 空间复杂度：$O(m+n)$，其中$m$是字符集的大小
