#+STARTUP: indent
* 抗锯齿类型 P39
* 透明排序算法 P42 [[https://zhuanlan.zhihu.com/p/368065919][图形学基础 - 着色 - 透明度混合-OIT]]
* 延迟着色法
** 计算出每个最终片元的位置、法线、材质等信息，保存在G-buffer中
** 对每个最终片元结合光源，计算光照、材质等形成最终颜色
* 延迟光照
** 计算出每个最终片元的位置、法线，保存在G-buffer中
** 对每个最终片元，结合光源，计算漫反射光和镜面光分别保存在两个缓冲区中
** 再次渲染整个场景，取出上一步两个缓冲区中的漫反射光合镜面光，结合物体材质计算最终颜色


* 水体模拟
** 正弦波
** Gerstner波
** FFT（从频域变换到时域）
* 水波焦散
** 从水底竖直向上逆向投射光线，经过水体表面法线折射，在光源（太阳）上采样
* 柏林噪声
** 格点处生成伪随机梯度，内部用Hermite插值
* 烟雾和火焰的降分辨率渲染
** 再叠加回去
* 无尽草的渲染
** 用instance
** 每个instance保存了中心坐标，基于中心坐标来位移
* 阴影体积法
** 在几何着色器里构建阴影体；通过triangles_adjacency来访问相邻三角形，通过法向量和光线向量的乘积正负来进行边缘检测
** 通过先渲染正面模版缓冲+1，再渲染背面模版缓冲-1，来标记阴影
* PCF
** 为什么可行：相邻片元的滤波器大面积重合
* 立方体贴图阴影
* 遮挡间隔贴图
** 借助纹理记录光源轻微移动时逐片元可见性的上升沿和下降沿，并进行均值模糊
* 次表面散射
** 偏移灯光漫反射项
#+BEGIN_SRC cpp
float diffuse = max(0, dot(L, N)); 
float wrap_diffuse = max(0, (dot(L, N) + wrap) / (1 + wrap)); 
#+END_SRC
** 在阴影判断时，通过和ShadowMap的深度对比来判断薄厚；薄者稍微透光
** 将物体的uv重映射到裁剪空间并且渲染到一张纹理上，之后对它应用高斯模糊并且叠加回去
* SSAO
* 随位移变化的IBL
** 令cubemap中心点为光源空间原点；创建一个半径为1的球，表面反射光线与球求交后的点作为向量输入cubemap纹理采样
* 纹理爆炸
** 对于每个格子通过伪随机数来制造偏移，并依据偏移在花纹纹理中采样；邻近格子除了绘制自己的花纹，也需要根据该偏移绘制花纹以保证花纹完整
* 实时光晕
** MRT将超过一定范围的光绘制到浮点帧缓冲上并进行高斯模糊，其余光绘制到另一个帧缓冲上
** 混合两个帧缓冲
* 景深渲染
** 渲染一个模糊帧缓冲，一个清晰帧缓冲；根据深度和景深范围，对二者进行不同比例混合
* 高质量滤波
** box滤波优化：先横再竖
** [[https://zhuanlan.zhihu.com/p/412456462][对灰阶数据的加速]]：对红绿蓝通道分别进行十字和对角线平移
* 通过偏导数来估计mipmap等级
** ddx和ddy可以计算出两个相邻像素的差值
* 图形管线性能
* [[https://zhuanlan.zhihu.com/p/415111099][高效遮挡剔除]]
** 先渲染包围盒，完全看不到的包围盒对应的物体应剔除
* 在实时渲染中实现高质量软渲染效果
** 通过预渲染各种信息到纹理，来保证实时软渲染的帧率
* 着色器管理
** 可以用条件宏来复用着色器
* 体渲染（光线投射）
** 将视点变换到物体空间，并通过片元在物体空间的坐标来进行射线采样
** 通过各方向上的变化率可以求出切线和法向量
* Clipmaps
** 用一个线程去加载DEM数据，然后渲染生成clipmap组，上下文共享纹理到主渲染线程，在主渲染线程中根据当前视点的位置，生成一组行列数相同，但是范围不同的“回”字型网格，在顶点着色器中对clipmap进行采样/插值，来填充网格的高度值（如果是放在三维球上，可能还要做一个从经纬高到xyz的变换）;然后在视点拉近的过程中，不断去生成更高精度的网格（同时移除精度最低的网格？）
* 几何体实例化
* 分段缓冲
* [[https://blog.csdn.net/McQueen_LT/article/details/106102609][Catmull-Clark细分]]
* 使用距离函数的逐像素位移映射（凹凸贴图）
* 分区纹理映射
* [[https://zhuanlan.zhihu.com/p/281571597][动态环境遮挡和间接光]]
* 蓝图渲染和草图绘制
** 深度剥离(depth peeling)
* 精确的大气散射
** Rayleigh散射和Mie散射
** AB和每条PC上光学深度的累加
** 可通过查找表（纹理）优化
** [[https://zhuanlan.zhihu.com/p/237502022][从零实现一套完整单次大气散射]]
** [[https://blog.csdn.net/qq_31615919/article/details/85938076?spm=1001.2014.3001.5502][基于GPU预计算的大气层光效渲染]]
* [[https://zhuanlan.zhihu.com/p/292074096][基于蒙特卡洛方法的PCF]]
* 使用顶点纹理位移的真实感水渲染
* 通用的折射模拟
** 通过法线贴图对屏幕坐标进行扰动来采样纹理，以产生折射效果
* 快速的预过滤线条
** 提前在距离线条不同远近的位置滤波，形成不同远近下的线条片元强度查找表
* 颜色LUT原理——使用查找表来加速颜色变换
* mipmap层级的测量
** 通过给不同层级的mipmap不同的颜色来测试运行时不同层级mipmap的覆盖率
* GPU上的八叉树纹理 
** 通过纹理值作为索引来查找纹理
* GPU生成复杂程序化地形
** Marching Cubes方法（类似Marching Squares算法生成等高线）
* CSM（级联阴影）
* 体积光
** 散射模型下，通过查寻ShadowMap，在阴影处不求加入的散射
** [[https://zhuanlan.zhihu.com/p/336079037][在屏幕空间采样到光源]]
* [[https://zhuanlan.zhihu.com/p/337140247][层次化距离贴图]]
* [[https://zhuanlan.zhihu.com/p/338694697][使用真实impostor技术渲染]]
* Gamma校正
* 后处理中的运动模糊
** 通过记录速度缓冲来进行运动模糊
** 方法是向运动方向采样
